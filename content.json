{"meta":{"title":"luchen","subtitle":null,"description":"所有的大人都曾是小孩子.","author":"luchen","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-02-02T14:06:46.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2017-02-02T13:42:01.000Z","updated":"2017-02-28T05:01:34.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"express+mongodb开发总结之crypto与session篇","slug":"express-mongodb开发总结之crypto与session篇","date":"2017-02-28T05:16:33.000Z","updated":"2017-02-28T05:57:17.000Z","comments":true,"path":"2017/02/28/express-mongodb开发总结之crypto与session篇/","link":"","permalink":"http://yoursite.com/2017/02/28/express-mongodb开发总结之crypto与session篇/","excerpt":"","text":"hash.update()方法就是将字符串相加，然后在hash.digest()将字符串加密返回 client先用certificate（得到server公钥）验证server身份，然后用这个公钥解密server发来的hello信息，ssl验证身份完以后 client随机生成一个大数，用server的公钥加密，传过去，server来解密得到，以后就用这个随机数作为master secret,然后双方用master secret生成最后的sessionkey，作为对称加密的key crypto： 不可逆，hash里面的hash模块，hmac模块（放置彩虹表攻击，在hash的基础上加了一个key） hash中，常用的用sha1就可以，时间长度都还可以，md5（32位） 1234567//对于登录密码，可以存key+密文，彩虹表也推不出来//对于登陆密码来说，是不需要考虑解密的，通常都会用不可逆的算法，像md5,sha-1等&#123; username: &apos;xxxx&apos; password: &apos;aead69a72da77d0615a854dda1086d885807574a&apos;, passkey:&apos;abc&apos;&#125; 可逆算法，crypto里面也有支持，cipher,decipher rc4和aes-256-cbc是表现不错的算法，加密和解密时间都比较短， 加密时间:解密时间=1:3；对于服务端加密，客户端解密的，aes-256-cbc算法的计算时间比例就可以。 签名和认证 还需要判断数据在传输过程中，是否真实际和完整，是否被篡改了。那么就需要用到签名和验证的算法，利用不对称加密算法，通过私钥进行数字签名，公钥验证数据的真实性。 签名： data -&gt; hashedData -&gt; 私钥加密 + 证书 -&gt; 签名后的。 解密： 更复杂一点的是，用认证机构的公钥去解密证书，得到公钥，用这个公钥（与签名者给的公钥比对，看是否是正确的公钥，签名者对不对）（这边验证了通信双方）。 用这个公钥去 解密 加密的数据，得到hashedData. === hash（data）.（这边验证数据是否完整）都正确的话就是身份认证结束。 用库的话，流程上就是： openssl命令生成公私钥，用私钥与数据得到数字签名（sign），用公钥，数据，数字签名去verifyverify(algorithm,pubkey,sig,data) salt： hash(text+salt) crypto.pbkdf2()函数，默认会调用hmac算法，用sha1的散列函数，并且可以设置迭代次数和密文长度salt也可以随机 bcrypt与native crypto库里面的方法的区别：bcrypt因为采用了Blowfish 算法， which has a computationally expensive key setup phase。常用于slow 加解密，比如那些不想让attacker获取的数据，比如 password,而crypto可以用于任何regular的情况，比如hmac也行。 mongo命令1db.users.update(&#123;username:&apos;some&apos;&#125;,&#123;$set:&#123;&quot;pass&quot;:&quot;barrymore&quot;&#125;&#125;) 用户注册流程 逻辑上，注册完成后（假设要邮箱验证），则hash(name,pass,secret),生成一个token给邮件的链接 12 '&lt;a href = \"' + SITE_ROOT_URL + '/active_account?key=' + token + '&amp;name=' + name + '\"&gt;激活链接&lt;/a&gt;' 然后用户请求激活账户这个action，后端用a标签中的token与自己存的token进行比对，看是否是用户发送的请求（csrf攻击的防范） 如果不需要邮箱验证，则直接后端调用login 的action（把刚刚得到的pass，与存进数据库的hash的pass传给verify的函数），验证成功。 然后再generateSessionID,(每次登录过后都要重新生成)，那么从登录到下一次登陆之前的请求，都用这个sessionId来验证 res.cookie中的{signed:true}到底做了什么操作因为signed本质是用hmac对data(plain cookie)做了处理，之前我们讲签名的时候就提到过，对data去hash一遍，这个hash就采用的hmac，因此要用到额外的key(secret)，就是传给cookieParser(key)的值，（本质做加盐防彩虹表），然后用底层的私钥去做了加密处理，最终设置到cookie里面。 楼主看了下这部分的代码，其实并没有做想象中的signed，（跟上面的openssl里面的数字签名还是不一样的）。cookie-parse调用了node-cookie-signature中的sign和unsign函数 12345678910exports.sign = function(val, secret)&#123; if ('string' != typeof val) throw new TypeError('cookie required'); if ('string' != typeof secret) throw new TypeError('secret required'); return val + '.' + crypto .createHmac('sha256', secret) .update(val) .digest('base64') .replace(/\\=+$/, ''); &#125;;//hmac(data,secret) =&gt; 'data.signedData' 实际上只做了一次hmac的加密。当服务端收到req时，可以用req.signedCookies来访问解析后的cookie,本质是用cookie-parser来解析传过来的signedcookie 需要注意的是用cookie-parser中间件的时候要传入secret,否则不会启用signedCookie 1234567891011121314151617181920212223242526function signedCookie (str, secret) &#123; //...省略部分代码，具体见链接 for (var i = 0; i &lt; secrets.length; i++) &#123; var val = signature.unsign(str.slice(2), secrets[i]) if (val !== false) &#123; return val &#125; &#125; return false &#125;//node-cookie-signature 包exports.unsign = function(val, secret)&#123;//val: 签名了的cookie(在express这边返回的实际上是刑如：`$&#123;plainCookie&#125;.$&#123;sign(plainCookie,secret&#125;`的值)） if ('string' != typeof val) throw new TypeError('cookie required'); if ('string' != typeof secret) throw new TypeError('secret required'); var str = val.slice(0, val.lastIndexOf('.')) , mac = exports.sign(str, secret); //用plainCookie，与secret去再次hmac得到的值，与收到的signed去比对，因为hmac不可逆..所以需要知道原始的plainData去重复操作验证 // 因为收到的是plain.signed 这个整体。（因为secret是server私有的（重点！，attacker无法知晓）），所以如果更改了这个,就会导致验证失败。 // 原始： var a = hmac('123','secret') =&gt; '123.a'， 如果attacker更改为'123.b' hmac(123,secret)！== '123.b'，验证失败 //疑问就是，那这个都仰仗secret的话，不是可以穷举secret么...因为express这边显示的把plain给写出来了，应该很容易穷举啊. //普通的hmac是不好破解的，因为我们知道它本身就是防范彩虹表攻击的，但是在express这边，感觉有点不安全... return sha1(mac) == sha1(val) ? str : false; //如果验证成功的话返回str,就是req.signedCookie&#125;; 小结： 为什么要session，不用cookie？ 答： session存放在服务端，通常情况下不会被窃取。 为什么要session 随机 &amp; 每次登陆后都重新生成 答： 随机，不容易被爆破，每次重新生成是防止一次窃取后每次都可以用它登陆。 session跟signedCookie有什么关系 答： 没有= =，两者不冲突，signedCookie只是用来防止数据被篡改的，session是用来验证身份的，有可能身份验证正确但是数据被篡改，因此cnode中同时设置了这个，并且可以设置httpOnly缓解XSS攻击（js不能访问带有该属性的cookie）。（因为cookie其实还是会被窃取的。） signedCookie关键在于 默认 secret是private的 补充： httpOnly是使得js不能访问带有该属性的cookie，同源策略是使得不能跨域访问 #####【碎碎念】 楼主装了editThisCookie的插件，里面有这么几个选项 分别是，secure:是否启用https, session:是否是session-cookie(与有expiration的固定cookie相对，每次关闭浏览器后就会erase掉，而persistent cookie则是除非expire或者手动erase，否则不会清除，他们都可以remember your action) There are two different types of cookies: Session cookies - these are temporary and are erased when you close your browser at the end of your surfing session. The next time you visit that particular site it will not recognise you and will treat you as a completely new visitor as there is nothing in your browser to let the site know that you have visited before (more on session cookies). Persistent cookies - these remain on your hard drive until you erase them or they expire. How long a cookie remains on your browser depends on how long the visited website has programmed the cookie to last (more on persistent cookies). 前端所知道的”一次登录后，maxAge时间内就不需要验证”，到底做了什么？ 实际上是，登录后，server生成随机的sessionID信息放到cookie/signedCookie里面，（并）然后下次req的时候，会自动携带cookie信息， 那么server对cookie里面的sessionID读取，并根据这个sessionID，去查与user的映射关系（就是存放session的地方，比如数据库），如果查找成功，则说明当前用户验证成功， 然后在maxAge时间内都进行这个操作。 所以说，不需要验证只是对前台不可见，实际上还是要做的。 （cnode的后台部分，就是把每一个请求的这一验证部分抽取成了authUser的中间件，先进行这一步操作，并挂在了req.session上，目的有二： 一是不要每次深层次查找数据，可以理解为一个快捷方式 另一方面其实是用了类似于connect-mongo的store中间件，用于sessionID与req.session的映射关系的存取，内部可以触发session存到store里面，监听maxAge等等，相当于用另外一张表来存取映射关系，而不是直接放在user表里面） 楼主后来又看了下session库，大致做了这么些操作，刚开始请求的时候，检查cookie信息，去设置req.sessionID,如果发现没有，则generate一个sessionID,req.session对象（Session类对象），进入next()，即后续 的其他路由、中间件等，有session的话return。但是在session函数里面其实还做了两件事件： 一个是onHeader函数，即，在要向浏览器发送数据包的时候，去setCookie. 12//用上面提到的node-cookie-signature去签名，（hmac(sessionID,secret)） -&gt; setCookie(name,signedCookie) setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data); 另一件是包抄res.end函数，在里面多加了一个save到store的过程，即以sessionID为key，把req.session对象写入数据库中。 ======更新=================== 更确切的说是，检测shouldSave(req),然后再看是否要save到store中，shouldsave中判断了sessionID以及session前后的hash值，有变动则save 1234// check if session has been modifiedfunction isModified(sess) &#123; return originalId !== sess.id || originalHash !== hash(sess);&#125; 而要做到session与user的关联，是要手动触发的，（是不会去主动监听的…）即当创建一个report时，要设置user.reportCount++（save到数据库）时，希望req.session.user里面也相应的更新的话，就要手动去改变。 在上面的shouldsave里面我们可以看到，可以直接操作req.session.user.replyCount，也可以将刚刚改变的user对象重新付给req.session，引用及数据变化，hash出来的自然不一样。就会在res.end中去更新session了。 ======更新=================== 以后每次请求都直接读取req.session即可。也就是说，简化了每次从req.cookie里面解析sessionID,然后查找之前建立的sessionid-&gt;user的映射表，以及后续的超时自动清除数据表等等其他收尾工作。维持一个”全局”对象（req.session）在一个登录有效期（多req）内持久存在的目的。 而用了session的中间件，你所需要做的就是告诉它name，secret(用于签名,required)，即可（不告诉genid的函数都可以，内部它用uid去创建的），然后把要放到cookie里面的东西挂在req.session对象上…奏是这么简单… 补充知识 session.save的options说明 sessionresave : 是指每次请求都重新设置session cookie，假设你的cookie是10分钟过期，每次请求都会再设置10分钟 Uninitialized: 是指无论有没有session cookie，每次请求都自动设置个session cookie ，默认给个标示为 connect.sid。一般建议用false，使得有权限才可以setcookie，同时也减轻server的压力。 secure: 应用在https reference Node.js加密算法库Crypto NodeJS: bcrypt vs native crypto What are “signed” cookies in connect/expressjs? all about cookie","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/开发/"}],"tags":[{"name":"express crypto session","slug":"express-crypto-session","permalink":"http://yoursite.com/tags/express-crypto-session/"}]},{"title":"早读课","slug":"早读课","date":"2017-02-28T05:12:14.000Z","updated":"2017-02-28T05:18:33.000Z","comments":true,"path":"2017/02/28/早读课/","link":"","permalink":"http://yoursite.com/2017/02/28/早读课/","excerpt":"","text":"event-loopjavascript： 同步任务（主线程）：存放于执行栈 异步任务：任务队列中(更确切的说是回调队列，queue,先进先出，但是有settimeout的特例) 主线程中执行会产生堆、栈，也同时会调用外部的api，会不断往任务队列中加入事件（click,mouseover…）。一旦执行栈中任务结束，就读取任务队列中，如果发现任务队列中某个异步事件有结果了（进入回调了），就拖到主线程的执行栈中执行。 event-loop是指：程序从主线程执行-&gt;调用外部api，在任务队列中放置事件-&gt;继续执行主线程-&gt;主线程清空/异步任务进入回调，执行任务队列中。（更新，更确切的说是，将task queue里面的函数提升到stack中去执行的这个事件一个一个循环的步骤） ======更新之前看阮大大的博客，后来被推荐看jsConf上的个视频讲解的很清楚，这边总结来说是：setTimeout(fn,delay): webapis将事件隔delay时间后插入task queue，即使将delay设为0，也只是表示立刻将fn插入task queue（尾部），但是什么时候执行，时间不定，要等当前代码执行完（执行栈清空）以后，即eventloop需要等到stack清空以后再push task(callback)queue中的fn到stack中去执行 对于ajax这些，是等数据返回后，再把回调放入queue中。 render queue跟callback queue一样，只不过有更高的优先级，当stack清空完以后，会首先执行它，因此如果是同步操作的话，会一直阻塞，让stack一直执行，render queue无法被call到，因此推荐异步，可以在执行间隙，每隔16ms（就会去访问下render queue，把它提上来（前提是stack清空））。 =======更新 end Nodejs中的event-loop添加了两个函数process.nextTick和setImmediate process.nextTick: 始终在当前执行栈的尾部添加（如果有多个process.nextTick语句，不管它们是否嵌套，将全部在当前”执行栈”执行。） setImmediate：始终在当前”任务队列”的尾部添加事件，如果嵌套，则下一轮，再下一轮.. setTimeout: 指定时间的话，是从当前执行开始计时，到时间就插入到task queue中，在任务队列的尾部添加。 关于setTimeout与setImmediate的执行顺序不定：（官方文档中说是在非I/O context下，两者执行顺序不定，由进程的性能决定，但是在I/o环境中，比如fs的回调中，setImmedite始终在setTimeout之前决定）但是： Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面。实际上，这种情况只发生在递归调用的时候。 12345678910111213141516//在Immediate中有两个函数Im和setTimeout, im的回调A始终在timeout之前，//在当前执行队列的最后，而B则是在下一轮event-loop，执行队列尾部setImmediate(function ()&#123; setImmediate(function A() &#123; console.log(1); setImmediate(function B()&#123;console.log(2);&#125;); &#125;); setTimeout(function timeout() &#123; console.log(&apos;TIMEOUT FIRED&apos;); &#125;, 0);&#125;);// 1// TIMEOUT FIRED// 2 结论： &gt;我们由此得到了process.nextTick和setImmediate的一个重要区别： 多个process.nextTick语句总是在当前&quot;执行栈&quot;一次执行完， 多个setImmediate可能则需要多次loop才能执行完。 因此，当递归调用process.nextTick的话，会被⚠️要求用immediate替代，因为这样会一直在执行栈中，不会去检查任务队列。 补充知识楼主看了下node里面介绍，关于process.nextTick，因为上面说它有一堆问题（什么递归调用会导致线程阻塞啊blahblah，那干嘛还要有这个api）。主要的原因是，比如在进入event-loop之前去做一些其他操作（有点点像finally），比如throw error以后， 12345function apiCall (arg, callback) &#123; if (typeof arg !== &apos;string&apos;) return process.nextTick(callback, new TypeError(&apos;argument should be string&apos;));&#125; 要执行error回调之前（event-loop）想执行其他操作，比如一些unneeded资源的回收，或者请求重传等等。还有的情况是诸如保证变量/函数定义、执行的先后顺序，看下面一个例子: 1234567891011121314151617const EventEmitter = require(&apos;events&apos;);const util = require(&apos;util&apos;);function MyEmitter() &#123; EventEmitter.call(this); this.emit(&apos;event&apos;); //1 //2 //process.nextTick(function () &#123; // this.emit(&apos;event&apos;); //&#125;.bind(this));&#125;util.inherits(MyEmitter, EventEmitter);const myEmitter = new MyEmitter();myEmitter.on(&apos;event&apos;, function() &#123; console.log(&apos;an event occurred!&apos;);//3&#125;); 用new执行完MyEmitter构造函数后，按理说要emit,但是这个时候其实并没有执行到下面（下面的on事件的注册也在执行栈中，不过还没调用到），因此emit要触发时还未定义。为了解决这个问题，应该将1处更改为2，那么，emit的触发会先暂缓，下面继续执行，event被注册，3处的回调被放入callback queue，然后这一步执行完后（也就是当前栈中的所有都已经执行完，只剩下刚刚nextTick中的emit）,此时，事件已注册，因此触发，栈清空，event-loop开始，回调被挪入stack中执行。 课后小测试123456789101112131415161718(function () &#123; console.log(&apos;this is the start&apos;); setTimeout(function cb() &#123; console.log(&apos;this is a msg from call back&apos;); &#125;); console.log(&apos;this is just a message&apos;); setTimeout(function cb1() &#123; console.log(&apos;this is a msg from call back1&apos;); &#125;, 0); console.log(&apos;this is the end&apos;);&#125;)();// 答案：","categories":[{"name":"日常阅读笔记","slug":"日常阅读笔记","permalink":"http://yoursite.com/categories/日常阅读笔记/"}],"tags":[{"name":"event-loop setTimeout","slug":"event-loop-setTimeout","permalink":"http://yoursite.com/tags/event-loop-setTimeout/"}]},{"title":"乱点技能树系列","slug":"乱点技能树系列","date":"2017-02-01T05:47:51.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2017/02/01/乱点技能树系列/","link":"","permalink":"http://yoursite.com/2017/02/01/乱点技能树系列/","excerpt":"","text":"1. 响应式图片 html中选择： srcset+ dpr 1234&lt;img srcset=&quot; examples/images/image-384.jpg 1x, examples/images/image-768.jpg 2x&quot; alt=&quot;…&quot;&gt; css media query+ dpr 12345678910.img &#123; background-image: url(examples/images/image-384.jpg); &#125;@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) &#123; .img &#123; background-image: url(examples/images/image-768.jpg); &#125;&#125; 这种方法还可以这么写。 12345 &lt;picture&gt; &lt;source srcset=&quot;extralarge.jpg&quot; media=&quot;(min-width: 1000px)&quot;&gt; &lt;source srcset=&quot;large.jpg&quot; media=&quot;(min-width: 800px)&quot;&gt; &lt;img srcset=&quot;medium.jpg&quot; alt=&quot;…&quot;&gt;&lt;/picture&gt; sizes in css + srcset 12345&lt;imgsizes=&quot;(min-width: 400px) 80vw, 100vw&quot;srcset=&quot;examples/images/small.jpg 375w, examples/images/big.jpg 1500w&quot;alt=&quot;…&quot;&gt; 浏览器通过计算不同大小的图片的 size/(视图尺寸dpr) ，选择最接近1的。比如上面就是 375/(3202） 1500/(320*2)。假设像素比为2. 2. CSS变量和预处理变量有什么不同css变量可以跟预处理变量达到同样的效果。同时在js中还可以访问到这些变量（属性）。那么就可以达到这样的效果： 通过js改变这些变量来统一变更样式，这样的好处是可以实现响应式栅格这种，嗯，楼主还想到了一键换肤=。=。 3. underscore学习curry化将很多参数转为连锁的函数调用 12345var property = function(key) &#123; return function(obj) &#123; return obj == null ? void 0 : obj[key]; &#125;; &#125;; void 0代替undefined原因 undefined在低版本浏览器中可以被重写，在局部作用域内也可以被重写（包括chrome）。 那么该用什么来代替undefined： void+表达式 1void (3+4) //undefined 除此之外，void 0要比undefined空间小，省下不少字节。","categories":[{"name":"杂","slug":"杂","permalink":"http://yoursite.com/categories/杂/"}],"tags":[{"name":"乱点技能树","slug":"乱点技能树","permalink":"http://yoursite.com/tags/乱点技能树/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"每日阅读清单","slug":"每日阅读清单","permalink":"http://yoursite.com/tags/每日阅读清单/"}]},{"title":"util笔记","slug":"util笔记","date":"2017-02-01T05:42:47.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2017/02/01/util笔记/","link":"","permalink":"http://yoursite.com/2017/02/01/util笔记/","excerpt":"","text":"1. arr swap123456Array.prototype.swap = function(lIndex,rIndex)&#123; var temp = this[rIndex]; this[rIndex] = this[lIndex]; this[lIndex] = temp; return this;&#125; 或者用call 12345678swap.call(nums,baseIndex,targetIndex);function swap(i,j)&#123; var temp; temp = this[j]; this[j] = this[i]; this[i] = temp; return this;&#125; 2. bubbleSort12345678910111213141516function bubbleSort()&#123; var swap = false; var arr = this.queue, lastIndexOfNotSortedArr = arr.length-1; do&#123; swap = false; for(var i=1;i&lt;=lastIndexOfNotSortedArr;i++)&#123; if(arr[i-1]&gt;arr[i]) &#123; arr.swap(i-1,i); swap = true; &#125; &#125; lastIndexOfNotSortedArr -=1; &#125;while(swap) &#125; 3. removeDuplicate用hash 1234567function removeDuplicate()&#123; var hashDict = &#123;&#125;; this.queue.forEach(function(data)&#123; hashDict[data] = true; &#125;); return Object.keys(hashDict); &#125;, 4. 日期格式化1234567891011121314function format(time,fmt)&#123; let dateObj = new Date(parseInt(time)); var o = &#123; &quot;M+&quot;: dateObj.getMonth() + 1, //月份 &quot;d+&quot;: dateObj.getDate(), //日 &quot;h+&quot;: dateObj.getHours(), //小时 &quot;m+&quot;: dateObj.getMinutes(), //分 &quot;s+&quot;: dateObj.getSeconds(), //秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (dateObj.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); for (let k in o) if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length))); return fmt;&#125; 5. push dynamic arr to arr楼主最近在刷leetcode，递归中会有不断push数组到result数组中的问题。但是碍于js的引用传值…结果经常就是一溜的同样的数组。微笑脸.jpg需要复制。。 123var a = [].concat(arr);es6就直接这样好了：b = [...arr]; 6. find target in a sorted array如果有则返回第一次出现的位置，如果不存在，则返回的是它如果要插入的话应该在的位置。leetcode 二分查找相关题目应用。123456789101112function searchIndex(target1)&#123; var i = 0, j = nums.length; //attention！ while (i &lt; j) &#123; var mid = Math.floor((i + j) / 2); if (nums[mid] &lt; target1) i = mid + 1; //i是最左边的===target的元素 else j = mid; &#125; return i;&#125; 需要注意的是： j的初始值应该是nums.length而不是nums.length-1 其次。循环终止条件不能是 while(i&lt;=j) 因为终止条件中i = mid。而循环中有j = mid。如果while(i&lt;=j)的话，就会导致死循环。 7. 数组应用12345678910111213141516171819function newObj()&#123; var Constructor = [].shift.call(arguments); var that = Object.create(Constructor.prototype); Constructor.apply(that,arguments); return that;&#125;var People = function(name,age)&#123; this.name = name; this.age = age;&#125;People.prototype = &#123; getName: function()&#123; return this.name &#125;, getAge: function()&#123; return this.age; &#125;&#125;var luchen = newObj(People,&quot;luchen&quot;,&quot;23&quot;); 划重点：其实跟我们平时用构造函数差不多。觉得比较好的是newObj里面的实现。-补充下： 123456// 类似于arraylikeObj.slice()var arr = Array.prototype.slice.call(arraylikeObj); //arguments.shift()第一个出队列var argument1 = [].shift.call(arguments)var leftArguments = arguments 8. 闭包实现单例利用的就是闭包可以一直访问外部变量，而外部变量也因为闭包的引用持久的存在于内存中。 1234567const singleton = (function()&#123; let param; return function(initialValue)&#123; return param || (param = initialValue); &#125;;&#125;)();singleton(&#123;someKey:value&#125;) === singleton(&#123;someKey:value&#125;) 还有一种更彻底的高阶函数的方式： 高阶函数是至少满足以下条件的函数：参数为函数返回值为函数 12345678910var getSingle = function(fn)&#123; var ret; return function()&#123; return ret || ret = fn.apply.call(arguments); &#125;&#125;var getScript = getSingle(function()&#123; return document.createElement(&apos;script&apos;);&#125;)getScript() === getScript()","categories":[{"name":"util","slug":"util","permalink":"http://yoursite.com/categories/util/"}],"tags":[{"name":"util","slug":"util","permalink":"http://yoursite.com/tags/util/"},{"name":"单例","slug":"单例","permalink":"http://yoursite.com/tags/单例/"},{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"}]},{"title":"Vue实践——Vuex","slug":"Vue实践——Vuex","date":"2017-02-01T05:34:10.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2017/02/01/Vue实践——Vuex/","link":"","permalink":"http://yoursite.com/2017/02/01/Vue实践——Vuex/","excerpt":"","text":"基本知识stateVuex提供了机制，使得设置 store选项（启用Vue.use(Vuex)）会将 store 从根组件『注入』到每一个子组件中。 1234567891011const app = new Vue(&#123; el: &apos;#app&apos;, // 使用 &quot;store&quot; 选项后，可以注册 store 对象。将会把 store 实例注入到所有子组件。 store, components: &#123; Counter &#125;, template: ` &lt;div class=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `&#125;) 子组件中可以通过this.$store.state.someprop访问mapState: 12345678910111213computed: mapState(&#123; count: state =&gt; state.count, countAlias: &apos;count&apos;, &apos;count&apos;, countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;) 或者用对象扩展方法将mapState作为computed的部分 computed:&#123; test1()&#123;..&#125;, ...mapState(&#123;&#125;) &#125; getters类似于store的计算属性函数,接受state作为第一个参数 1234567const store = new Vuex.Store(&#123; state: &#123; &#125;, getters: &#123; doneTodos: state =&gt; ... &#125;&#125;) 组件中用this.$store.getters.blah访问 Mutations 遵循响应式规则，即预先初始化，需要增加属性时，用set或者新对象来替换旧对象。 常量命名Mutation，统一管理 同步函数 每个mutation都有一个type和一个回调函数。回调函数的参数为state，也接受payload actions 不改变state,只commit，类似于emit一个事件。 可以处理异步操作，弥补mutation只能是同步函数的问题。 处理参数接受context为参数。context包括与store实例相同的方法和属性。可以用es6参数解构来获得里面的commit等 更新1,vuex重构了todo,见github 更新2 需要注意的是，整个操作中只通过在store里面提交mutations来实现数据的更改，（便于用dev-统一tool去统一跟踪）。 总的来说，vuex解决的是用纯数据交互的方式来处理原本属于组件间（sibling组件）的通信，有人会说那我用event也可以做到通信啊，但是当组件创建、销毁时，这些状态也随之变动，因此需要有一个独立于组件的状态树来进行维护。在知乎上看到一个回答，挺好的： Vuex的主要作用是各组件间的状态同步（以及同一组件再次显示时的状态保持）。特别是非数据库内容。比如网页右上角的搜索框，并不像日志列表那样对应数据库内容。如果不希望每次进入有搜索框的模板页面，搜索框内容都被重置，那么就需要高于组件的架构 题外话： 以往的操作是: parentA childB childC子组件（B,C）要调用A的回调，那么通过props传递到B,C即可。A中要调用B.C的方法/属性，那么也可以通过props回调，然后把B,C的属性/方法作为参数 this.props.Afn(bVal,cVal,bFn,cFn)这样。（当然这是在B,C内部操作）。如果一定要在A中执行，可以this.ref.B.blah(以react为例)在vue中，通信中props的部分跟react一样，当然也可以通过(特别是孙孙组件这种层级特别多的)事件，B,C中emit,A中on而事件也适用于sibling之间的通信，如B,C。栗子可以看react 以shopping-cart为例来分析vuex的goods子组件为cart和products。购物车和商品列表。 event-bus功能：当商品需要加入购物车的时候，需要在商品列表中-1,购物车中添加。那么就应该dispatch一个add_to_cart action到根store。然后根storecommit一个mutation，而这个时候，购物车和商品列表中都有同名ADD_TO_CART mutation，就会同时执行。变相的实现event-bus的功能。 避免数据冗余：除此之外，cart中只存变动的added products的id,quantity数量，虽然cart组件中有added product的信息，但是这些不存在cart store中，而是存放在根store,根据added数组中的id去查询products，然后得到products getters供cart组件使用。使得数据冗余减少了很多，组件不存储无关state. 全局提升。虽然有module，但是它们都是注册在全局上的，也就是会被提升，保证了同一个action有可能调用多个同名mutation（是通过维护数组来实现的）mutations中其实是包括了两个module+根的mutation，但是可以看到这边都被合并了，维护一个队列来进行分发。(一个dispatch也可能会触发多个模块的同名action，如果action中返回的是promise,那么等所有的action都结束完才会执行then) 需要用vuex/Immutable的原因 vue踩下的坑： props传递引用对象（浅复制）比如这边的wigetList就是一个数组对象，是作为editModal这个子组件的props进行传递的，而子组件的一个data:list以wigetList为初始值，当点击multiSelect（即传进来的是protocol:[]数组，变动这个数组时）等变动list的时候，由于传递引用，会导致外层的wigetList变动，造成新一轮的props更新，所有list中非引用的对象都会被重新初始化掉，（注意是非引用对象，像input值传进来，内部变动是不会影响外部的）应该是传类似于这种： 1234[&#123; input: &apos;tet&apos;, //不会改变外部 select: [&apos;test1&apos;,&apos;test2&apos;]//会作用于外部&#125;] 这样就违背了数据单向传递的目的，那么所有引用这个wigetList的值都会相应的被变化。应该是props传递进来的时候用的浅复制，类似于Object.assign.对每个key遍历赋值，然后基本类型都赋值，但是引用赋的还是对象。一种解决方案是传递immutable数据（蠢蠢的方法是JSON序列化掉然后传进来…）。还有一种是虽然传引用，但是赋值（data用props初始化的时候）用深拷贝(这边用的lodash的深拷贝)。 123456789101112131415import cloneDeep from &apos;lodash/cloneDeep&apos;data() &#123;return &#123; showModal: this.show, wigets: cloneDeep(this.wigetList), //here form: &#123;...wigetTest&#125;&#125;;&#125;,watch:&#123;show(val)&#123; this.showModal = val;&#125;,wigetList(val)&#123; this.wigets = cloneDeep(val); //here ~&#125; case 全局维护tab. 当click tab时，dispatch一个“changeTab”的action,根store响应，根commit一个CHANGE_TAB的mutation（tab = newTab），然后同名的module里面的mutation执行（比如reset等等）。 之前的方法是这样处理的：在page1中监听tab变动，等根的tab state变动完后reset. 123456789101112131415161718192021//page1: watch: &#123; &apos;$route&apos;(to,from) &#123; //监听tab导致的路由变动 if(to.query &amp;&amp; to.query.tab)&#123; this.$store.dispatch(&apos;changeTab&apos;,to.query.tab).then(()=&gt;&#123; this.reset(); &#125;) &#125; &#125; &#125;,//根storeconst actions = &#123; changeTab(&#123;commit&#125;,tab)&#123; //返回一个promise return new Promise((resolve,reject)=&gt;&#123; commit(types.CHANGE_TAB,tab); resolve(); &#125;) &#125;&#125;","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yoursite.com/categories/日常开发/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://yoursite.com/tags/Vuex/"},{"name":"坑","slug":"坑","permalink":"http://yoursite.com/tags/坑/"}]},{"title":"FE玩耍专栏（二）之缩小版","slug":"FE玩耍专栏（二）之缩小版","date":"2017-02-01T05:09:53.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2017/02/01/FE玩耍专栏（二）之缩小版/","link":"","permalink":"http://yoursite.com/2017/02/01/FE玩耍专栏（二）之缩小版/","excerpt":"","text":"末尾显示省略号（ellipsis）分两种，单行跟多行。 以单行为例。需要设置一个宽度，这样才有overflow的情况。同时设置超出后显示省略号。除此之外，因为设了宽度，会默认换行，那么就达不到overflow的情况，所以要阻止换行，用nowrap使得一行显示。 123456.ellipsis-single&#123; width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125; 多行的话，设置最多行数(-webkit-line-clamp) 123-webkit-line-clamp,display: -webkit-box-webkit-box-orient 具体的demo见[codepen]哈 See the Pen ellipsis test with single line and multiple lines by lu (@luchen) on CodePen. tagged inputSee the Pen tagged input via vue by lu (@luchen) on CodePen. 这个demo目的是： 轮子，交互友好，因为常用pocket跟evernote，就有打tag的场景，但是element没有相应的组件。 实践了一下vue所说的v-model的语法糖。总结来说就是 1v-model = value+ $emit(&apos;input&apos;) 子组件新建一个data,维持从父类传来的props(value)作为初始值，每次子组件data(或者更精确点说是：要传出去的数值)变动时$emit，通知父组件变动。是由内往外的数据传输。 svg 制作进度环part1：基础知识： 通用指令：stroke stroke-width stroke-color stroke-linecap stroke-dashedarray fill 常用指令： circle &lt;circle cx cy r&gt;&lt;/circle&gt; path: d>```1- polygon：```&lt;polygon points&gt;&lt;/polygon&gt; 所有的大写表示绝对路径，小写为相对偏移 123456789101112131415161718192021222324path相关指令：M = moveto 标志起点终点等 eg M 100 100//group2L = lineto H = horizontal lineto V = vertical lineto //直线终点eg L 100 200//group3C =curveto S = smooth curveto Q = quadratic Bézier curve T = smooth C 为两个控制点+终点，如三次贝塞尔曲线中，会有两个控制点。eg.&lt;path d=&quot;M70 60 C 70 80, 110 80, 110 60&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;S:表示简写控制点，表示它的第一个控制点与前面的S/C的控制点的对称点:S C2 endP Q 为二次贝塞尔曲线的一个控制点,类似于CT前面需要有Q或者TA = elliptical Arc A x-radius y-radius x-rotation large-arc-flag（角度大小）sweep-flagZ = closepath part2： 划重点 圆环： 用circle+fill:none+stroke绘制而成 slider：用path+arc指令+fill:none去绘制弧 注意点： viewbox与svg之间的scale和坐标映射问题。整个的绘制是以viewbox为基准的，而交互操作的坐标是需要先转为相对于svg,然后再scale到viewBox的。关于viewbox，viewport等的问题，戳张鑫旭大神的文章科普下理解SVG的viewport,viewBox,preserveAspectRatio。viewbox的一个好处，可以认为是可以自适应container的同时开发人员可以只针对viewbox的坐标系统进行开发。有点类似于移动端设置rem,开发人员只要对750px的去进行编写各种px,最终都会根据环境去相应的映射到正确的宽高大小。 精度缺失问题： 当percent为100传过去得到弧度制的角度时，因为Math.PI本身无限循环下去，有精度损失。我们看到而正常理解中，sin(360°)应该为0。就导致最终画满格的时候会出现这样的情况。所以楼主暗搓搓的检测100%时手动变成了99.9%。捂脸… Math.sin等函数接受的是弧度制非角度制，需要预先进行处理 交互方面：设置了点击以及mousemove的部分。对于坐标的检测，检测clientX,并映射到viewbox内。然后根据（x-c1）^2 +(y-c2)^2 = r^2。去计算y，而这个时候得到的会有两个y，对称于直径。那么就需要根据clientY去进行筛选匹配，从而得到正确的圆上坐标。，去绘制arc path。然后根据坐标去计算夹角，得到percent。最终更新data。 最终的demo戳这个链接，但是不知道为什么放到codepen里面，第三幅图的数据没有更新（func props没有传下去）。实测是可以的。 See the Pen sliding circle via svg by lu (@luchen) on CodePen. 补充： 因为同时有click跟mousedown,mousemove,mouseup。为了避免冲突，楼主把mouse部分放在了path上，click放在了circle上。具体场景可以看可以看到当在只注册了mousedown,up的path上进行click，会依次执行down,up。如果绑在同一个元素上，就有冲突，会执行三条，那么就需要用时间进行下面的区分操作： 在mousedown的时候,记录当前的时间,然后在mouseup的时候,再取当前时间,然后判断这两个时间差,当它大于某个数值的时候(因为如果是click,那么会在很短时间内产生mouseup),就不认为它是click。更精确的还可以加上mousedown和mouseup的坐标，不同则非click。 网上看到一个setTimeout的解决方案,小于200ms的就执行click操作： 12345678910111213141516$(element).click(function()&#123; // click code in here &#125;);$(element).MouseDown(function()&#123; onMouseDownFlag = false; mouseDownAndUpTimer = setTimeout(function()&#123; // OnMouseDown Code in here onMouseDownFlag = true; &#125;,200);&#125;).MouseUp(function()&#123; if(onMouseDownFlag)&#123; // OnMouseUp Code in here &#125;else&#123; clearTimeout(mouseDownAndUpTimer); // 清除延迟时间 &#125;&#125;); PS:楼主之前看到circle还有一种很巧妙的方法。简要来说是用path(arc)+stroke-dasharray去处理。一个环就是一个stoke-dasharray [first second]。first的长度即为当前percent的亮色部分。second即为灰色的部分。但是这种方法不是很好做mousemove。所以楼主就作罢嘞 对比一下tagged input和circle,这两个都是vue组件的编写，都涉及父子组件的通信，区别在于，第一种是 子组件新建一个data,维持从父类传来的props作为初始值，每次子组件变动时$emit，通知父组件变动。是由内往外的数据传输。第二种的version1版本是父组件传props进内部，外部进行变动，反应到子组件，相应变化。（此时没有data.）当需要增加需求（version2，即需要交互滑动circle）时，就需要增加一个currentValue的data,以props percent初始化，一方面需要watch percent的变动（外-&gt;内）,另一方面当自己变化时，需要告知外部，即调用onPercentChange(val) 的props回调。 references path in svg donut via d3效果图如下，两圈圆分别代表内外部数据，mouseover到内侧时，会在中心显示相应的数据，外侧均分的arc，由折线引出它关联的数据、图标等等。下面我们来看下实现 首先生成一个饼图123456const arcs = d3.pie() .startAngle(-90 * Math.PI/180) .endAngle(-90 * Math.PI/180 + 2*Math.PI) .value(d=&gt; d.value) .padAngle(.01) .sortValues((a,b)=&gt;(b-a)(innerData); d3.pie()返回一个generator(实际上是一个函数，接受data数组作为参数），d3.pie(data)最终生成一个由data map出来的新数组 arr，arr的每一个元素是一个有以下属性的obj,每一个obj标志了一个arc弧： data - the input datum; the corresponding element in the input data array.value - the numeric value of the arc.index - the zero-based sorted index of the arc.startAngle - the start angle of the arc.endAngle - the end angle of the arc.padAngle - the pad angle of the arc. 123const arc = d3.arc().innerRadius(config.innerRadius) .outerRadius(config.innerRadius+20) .cornerRadius(5); 生成各部分arcarc也是一个函数，对上面绘制的pie进行限定（内外半径+padding）arc(data2)生成&quot;M0,-100A100,100,0,0,1,100,0L0,0Z这样的数据，传递给pathd3.append(&quot;path&quot;).attr(&quot;d&quot;,arc)，最终就出来一条弧。 注： path.data(innerData).attr(&quot;d&quot;，func)第二个参数为一个函数(这边即为arc函数)，接受innerData中的每一个obj为参数,这些数据作为新的绘制数据被传递给path，从而最终得到饼图。 该部分代码如下： 12345678910111213141516171819202122232425//firstconst pie = d3.pie() .startAngle(0) .endAngle(2 * Math.PI) //-90 * Math.PI/180 + .value(d =&gt; d.value) .padAngle(.02) .sortValues((a, b) =&gt; (b - a));//secondconst inner = svg.append(\"g\").attr(\"class\", \"inner\") .attr(\"width\", config.width * 0.4) .attr(\"height\", config.height * 0.4) .attr(\"transform\", `translate($&#123;config.width/2&#125;,$&#123;config.height/2&#125;)`); const arc = d3.arc().innerRadius(config.innerRadius) .outerRadius(config.innerRadius + 20) .cornerRadius(5); const arcItem = inner.selectAll(\".donutArc\").data(transformedData) .enter().append(\"g\") .attr(\"class\", \"donutArc\") .append(\"path\") .each(d =&gt; d.outerRadius = outerRadius) .attr(\"d\", arc) .style('fill', (d, i) =&gt; d3.schemeCategory10[i]); 总结来说，d3.pie()(data) 得到【obj1,obj2】,每个obj又赋值给arcd3.arc(obj1)，得到path的d属性数据。 折线部分这边主要思路是定义一条polyline的三个点去生成线段，三点分别为outerArc的中心，隐藏的一个圆的centroid,以及自定义的终点。 1234567outItem.append(\"polyline\").attr(\"class\", \"polyline\") .attr(\"points\", d =&gt; &#123; let point3 = largeOutArc.centroid(d); d.outArcCen = [...point3]; point3[0] = config.width / 2 * 0.7 * (midAngle(d) &gt; Math.PI ? -1 : 1); return [outerArc.centroid(d), largeOutArc.centroid(d), point3] &#125;); 图片与文字部分这边需要注意的是，由于楼主最开始使用了es6的语法，因此在attr的回调函数中无法d3.select(this)去得到元素，（es6中绑定的this是外层定义时的this），下面我们会提到的mouseover事件中也是。还有一个问题是，因为image元素随着group 进行了transform，因此实际上是左上角在现在的圆心处，应该反transform自身的一部分，使之居中后再去发散到四周。因此这边用x,y去预先定义了他们的位置。而文字，没有图片那么麻烦，可以直接用text-anchor进行处理。 1234567891011121314151617181920212223//图标 outItem.append(\"image\").attr(\"class\", \"image\") .attr(\"xlink:href\", d =&gt; d.data.href) .attr(\"x\", (d, i, nodes) =&gt; -nodes[i].getBBox().width / 2) .attr(\"y\", (d, i, nodes) =&gt; -nodes[i].getBBox().height / 2) // .attr(\"y\",(()=&gt; -1*this.getBBox().height/2)() .attr(\"transform\", (d, i) =&gt; &#123; let point3 = [...d.outArcCen]; point3[0] = config.width / 2 * 0.85 * (midAngle(d) &gt; Math.PI ? -1 : 1); d.endPoint = point3; return 'translate(' + point3 + ')'; &#125;) // text 公司描述 outItem.append(\"text\").attr(\"dy\", \"-.35em\").attr(\"class\", \"text\") .attr(\"transform\", d =&gt; &#123; const interpolate = d3.interpolate(d.outArcCen, d.endPoint); const newPoint = interpolate(0.2); return 'translate(' + newPoint + ')'; &#125;) .text(d =&gt; d.data.name); 绑定事件attr(attrname,value): 对相应的元素的属性进行设置，value可以为值，也可以为函数，如果是func的话，会被立即调用。因为这边的需求是mouseover上（d3里面没有hover、mouseenter等函数）显著标出。（最开始楼主设置了scale,但是svg元素中不支持transform-origin，因此没有办法设置center,使得偏离位置，不停触发mouseover）。后来就保持内半径不变… attrTween(attrname,value): value作为函数时，应该返回的是一个参数为time（时刻）的插值器(函数)，插值器的返回值作为value被设置成时刻t时该属性的值 1234567891011//官方api//内置插值器selection.attrTween(\"fill\", function() &#123; return d3.interpolateRgb(\"red\", \"blue\");&#125;);//自定义插值器selection.attrTween(\"fill\", function() &#123; return function(t) &#123; return \"hsl(\" + t * 360 + \",100%,50%)\"; &#125;;&#125;); 123456789101112131415161718192021222324 arcItem.on(\"mouseover\", handleMouseOver)//es6箭头函数会丢失this,函数内部无法d3.select(this)得到绑定事件的元素 .on(\"mouseout\", handleMouseOut)function attrTween(outerRadius, duration) &#123; return function() &#123; d3.select(this).transition() .duration(duration) .attrTween(\"d\", (d) =&gt; &#123;//在两个状态间转变，加上transition缓动动画 const timingFun = d3.interpolate(d.outerRadius, outerRadius); return (t) =&gt; &#123; arc.outerRadius(timingFun(t)); return arc(d);//最终的返回值 &#125; &#125;) &#125; &#125; function handleMouseOver(obj, i, nodes) &#123; // debugger context.cur = &#123; catetory: obj.data.name, statistics: obj.data.value &#125;; d3.select(this).transition() .attr(\"d\", attrTween(outerRadius + 20, 500)) &#125; 补充知识svg viewport、viewbox、viewPort: 视窗，svg声明width,height的部分 1&lt;svg width=&quot;800&quot; height=&quot;600&quot; &gt; 一建立viewport，就会创建初始的视窗坐标系和用户坐标系 视窗坐标系是建立在视窗中的， 用户坐标系是建立在画布上的（viewbox限定），真实坐标系。 初始时，两者相同，但可以后续设置使之不一致 1&lt;svg width=\"800\" height=\"600\" viewbox=\"200 200 400 400\"&gt; viewbox属性分别对应： leftTopX,leftTopY,width,height声明了一个区域，在viewport中裁切出来，然后拉伸来适应viewPort。 当viewbox与viewPort的比例不一致的时候，可以用preserveAspectRatio 来保持长宽比，又涉及到两个参数“alignment meet/slice”meet用于按照viewbox大小去按比例适应viewport（设宽比a,高比为b，按照比例小的去适应）,如上面的比例1：1，会适应成600 600.而slice则会（尽可能充满viewport，按照大比例去）适应后去裁切。alignment表明的是viewport与viewbox的按照哪些轴对齐 参考文章可以看 张鑫旭的， 还有这篇理解SVG坐标系和变换：视窗,viewBox和preserveAspectRatio， 测试网站 A Look At SVG viewBox and viewport extending the arc 注意点： 在svg元素上的transform是不会继承给子元素的，只有绑在g element上才可以。如图： 具体戳这边的链接Drawback: G Elements Have no X and Y Attributes 否则，得手动一层层的把transform复制给子元素，可以看到下图中，transform直接设置在svg上，inner没有做任何处理，outer需要设置与svg同样的位移才居中。 transform-origin不存在于svg的属性中，是css的属性 First of all, transform-origin is a pure CSS 3 property, it is not related to SVG 1.1 at all. Despite the fact that transform sounds a lot like transform-origin, they apply to different systems. transform exists in both CSS 3 and SVG 1.1 but have separate implementations. transform-origin only exists in CSS 3 and therefore it is not supposed to influence SVG 1.1. The fact that transform-origin has no influence on SVG in Chrome 48 is expected. 事件中的this","categories":[{"name":"日常开发","slug":"日常开发","permalink":"http://yoursite.com/categories/日常开发/"}],"tags":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/tags/开发/"},{"name":"好玩的","slug":"好玩的","permalink":"http://yoursite.com/tags/好玩的/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"日常玩耍","slug":"日常玩耍","permalink":"http://yoursite.com/tags/日常玩耍/"},{"name":"svg","slug":"svg","permalink":"http://yoursite.com/tags/svg/"}]},{"title":"javascript设计模式（三）","slug":"design-principle3","date":"2017-01-31T12:22:58.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2017/01/31/design-principle3/","link":"","permalink":"http://yoursite.com/2017/01/31/design-principle3/","excerpt":"","text":"发布-订阅模式其实这个模式使用频率很多，之前楼主写react的时候，就遇到过这么个场景，一个页面中涉及的组件有： form part（一堆筛选控件，如一级二级select，datepicker，地理位置选择器等等） slider嵌套的多个card，card内部又有统计数据部分和echarts图表部分，随着formpart的变动而更改。 card中的数据变动不定，而且里面有很多子组件，最开始的时候通信是用props一层层的传递下去，这样遇到两个问题： 组件嵌套过深时，通过props传递时，中间组件由于中介作用需要传递很多中间数据 从grandparent传递下来，使得很多实际并没有变化的card也进行了渲染。（嗯，可以用should component update检测，这是后话）。 中途进行了一个重构就是引入了event-bus.每个card 注册监听事件，监听ajax的success中数据的返回（包括应该变更的card ID），如果是自己该更新，那么就render。而那些无需变动的card选择忽略就好。 后来写的vue项目中，（1.0版本的时候还有$broadcast 跟$dispatch等等），2.0版本中只有$emit，在父组件中注册监听事件，（有点点像只有一层的props传递函数）。除此之外，还有watch方法，computed计算属性等等，都是发布-订阅模式的一个实现。 实现1234567891011121314151617181920212223242526272829var event = &#123; observers: [], listen:function(eventName,fn)&#123; if(!this.observers[eventName]) this.observers[eventName] = []; this.observers[eventName].push(fn); &#125;, trigger:function()&#123; var eventName = Array.protptype.shift.call(arguments), fnArr = this.observers[eventName]; if(!fnArr|| fnArr.length===0) return false; for(var i=0;i&lt;fnArr.length;i++) fn.apply(this,arguments); &#125;&#125;var installEvent = function(obj)&#123; for(var i in evnt)&#123; obj[i] = event[i]; &#125;&#125;var salsesOffice = &#123;&#125;;installEvent(salsesOffice);salsesOffice.listen('eventName',function(v)&#123; console.log(\" person1 is listening \",v);&#125;)salsesOffice.trigger('eventName','test'); 取消订阅的话，只需要在fnsArr里面splice即可。这边的observer是function。其他的case有很多，上面我们已经说过了，书中提到的例子有网站登录 上面的方法还有一个小问题是，在observer代码里，需要知晓它监听的对象，即login。那么有一种方法是建立一个全局的事件对象，类似于中介者，去进行事件的统筹分配。订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订阅者，Event作为一个类似“中介者”的角色，把订阅者和发布者联系起来。 123456789101112131415//全局Event对象var Event = (function()&#123; var observers = &#123;&#125;,//&#123;'eventName1':[fn1,fn2],'eventName2':[watcher1,watcher2]&#125; listen,trigger,remove; //三个函数的定义 //... return&#123; listen: listen, trigger: trigger, remove: remove &#125;&#125;)();Event.listen('eventName1',fn1);Event.trigger('eventName1',param1);Event.remove('eventName1',fn1); 全局event对象的一个不足之处是会造成命名冲突，因此可以添加namespace，具体代码见书。 后话是，楼主用event重构的react的项目后来又换回去了一部分，因为一是性能问题可以用shouldcomponentupdate来解决，另一方面，大量的event不好追踪一个事件的双方，那么模块与模块之间的联系就被隐藏到了背后。我们最终会搞不清楚消息来自哪个模块，或者消息会流向哪些模块，感觉一个代码里充斥着越过组件的攻击曲线..=.= 作用问： 跟加了回调的代理模式有啥区别？ 可以不再显式调用某一个函数，达到松散耦合，比如说，之前在登录成功的回调里面处理header，nav的信息，当模块多了的话会要不停修改login成功回调，现在不需要动登陆成功的回调函数，只要各自监听就好，可以不断添加observer。 而且，局部订阅者模式是在某一方加了接口，而代理是在两方基础上添加一个中间处理方：一种是保护，另一种是多做一些性能的额外处理，比如合并请求，预加载，懒加载等等。那中介者模式呢… 其他 符合“好莱坞原则” 离线消息的存在必要性： 在很多情况下，并不是严格按照订阅-发布的时间顺序，比如ajax回调中会trigger一个事件，但是trigger事件的时候，可能没有订阅者，或者订阅者还没有准备好，那么他们就无法捕获到这个事件的发生，就会遗漏事件，因此有必要将暂时还没有接受者的事件存储下来，当出现订阅者时发送给他们，执行一次即可，阅后即焚… 中介者模式当对象变多时，他们之间的关系错综复杂，中介者模式就是为了解除对象之间的紧密耦合关系而存在的，应用以后对象之间都通过中介者通信，互相不透镜，使得多对多关系变为比较简单的一对多关系。 其实之前在观察者模式中我们也涉及到了中介者模式，就是最后的全局Event对象，它对对象之间的注册触发进行了统筹。 既然放一起了，就做个区分吧： 观察者模式最朴素的是A，B之间进行处理，A需要知道B的存在，就是多对多的关系。改进一点的方法是用中间的全局Event对象去进行管理。仔细想一下的话，中介者模式是为了观察者模式做服务的，它只是用来处理双方之间的关系，而观察者模式是用来解决消息通知问题的，中介者是为了观察者模式更好的进行而存在的。 盗图一张… 书中的一个例子是玩游戏，设用户为A,B,C…添加一个中间人，每次A,B等有操作时通知中间人。 12345678910111213/** * 中介者模式的话，需要各对象在操作时通知中介者 * @return &#123;[type]&#125; [description] */Player.prototype.die = function() &#123; this.state = 'dead'; playerDirector.ReceiveMessage('playerDead', this); // 给中介者发送消息，玩家死亡，this告知中介者当前对象&#125;/*******************移除玩家*****************/Player.prototype.remove = function()&#123; playerDirector.ReceiveMessage( 'removePlayer', this ); // 给中介者发送消息，移除一个玩家&#125;;&#125; 上面的代码是对象通知中介者，那中介者收到这些消息后进行处理，会将信息发送给各对象，这边可以遍历，调用对象的方法。 123456 //中介者通知其他人if (all_dead === true) &#123; // 全部死亡 for ( var i = 0, player; player = teamPlayers[ i++]; )&#123; player.lose(); // 本队所有玩家lose &#125; &#125;&#125; 而关于这个中介者的实现上，书中提到了两种方法：&gt; 利用发布—订阅模式。将playerDirector实现为订阅者，各player作为发布者，一旦player的状态发生改变，便推送消息给playerDirector，playerDirector处理消息后将反馈发送给其他player。在playerDirector中开放一些接收消息的接口，各player可以直接调用该接口来给playerDirector发送消息，player只需传递一个参数给playerDirector，这个参数（书中为 this ，即当前对象）的目的是使playerDirector可以识别发送者。同样，playerDirector接收到消息之后会将处理结果反馈给其他player。 中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象（类似不和陌生人说话）。 【summary】中介者模式总结来说，是将耦合转嫁到一个中间人去管理这些，类似于“上帝之手”，解决的是对象之间的关系。 装饰器模式在程序开发中，许多时候都并不希望某个类天生就非常庞大，一次性包含许多职责。那么我们就可以使用装饰者模式，不停的包装对象，生成一个又一个嵌套的对象，每次都增加一丢丢功能，类似于俄罗斯套娃。 装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。 这种功能通常可以用继承来做，但是存在一点问题，就是： 会造成父类和子类的强耦合，父类改变时，子类会随之变动 当功能增多是，会出现大量的子类 而装饰器模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法。 JavaScript天然可以增加属性/职责，如下：obj.address = obj.address +&#39;福田区&#39; 示例1234567891011//原始var plane = &#123; fire: function()&#123; console.log( '发射普通子弹' ); &#125; &#125;var _fire = plane.fire;plane.fire = function()&#123; _fire(); someOtherFun();&#125; 这种方法最简单粗暴，直接改写了原有方法（覆盖），增加了中间变量_fire（一定要增加…否则就是递归调用了=。=）。而且有时候会遇到this被劫持的问题，比如document.getElementById中的this.正确的写法如下 123456789101112131415161718Function.prototype.before = function(beforeFn)&#123; var fn = this; return function () &#123; beforeFn.apply(this,arguments); return fn.apply(this,arguments) &#125;&#125;var test = function(param)&#123; console.log('test',param);&#125;var after = test.before(function(param2)&#123; console.log('before ',param2); &#125;);after('final result'); 还有一个validate的部分，在策略模式那边添加了部分代码，可以走过路过看一下：） 装饰器模式与代理模式 代理模式通常只有一层代理-本体的引用，而装饰者模式经常会形成一条长长的装饰链。 装饰器模式与代理模式都是为本体添加功能，但是前者是真正添加额外功能，而后者是将原有功能优化，如性能等 适配器模式这种模式相对简单，主要是针对接口的兼容修补工作，使得A，B两个对外呈现的接口一致。 12345678910111213141516var googleMap = &#123; show: function() &#123; console.log('开始渲染谷歌地图'); &#125; &#125;;var baiduMap = &#123; display: function() &#123; console.log('开始渲染百度地图'); &#125;&#125;;//here display-&gt; show兼容var baiduMapAdapter = &#123; show: function()&#123; return baiduMap.display(); &#125; &#125;; ####区分 装饰器模式会形成长长的包装链、代理和适配器只包装一次。代理模式是不变功能，只是功能更加聪明，性能更好，装饰器是增加功能，适配器模式是改外部接口，不涉及内部功能。 享元模式常用于性能优化，如果项目中有大量的相似对象，可以把他们的状态抽取成可以共用的内部状态和外部的场景状态。 如书中介绍到的内衣工厂，model对象的属性为性别，整个项目中设置两个对象，男女模特，然后衣服设置为外部状态。 12345678910var Model = function( sex )&#123; this.sex = sex;&#125;;Model.prototype.takePhoto = function()&#123; console.log( 'sex= ' +this.sex +' underwear=' +this.underwear);&#125;;for ( var j = 1; j &lt;= 50; j++)&#123; femaleModel.underwear = 'underwear' +j; //外部状态 femaleModel.takePhoto();&#125;; 通常来说，内部状态有多少种组合，系统中就有多少个对象。 另一个case就是文件上传（敲黑板，之前文件上传的时候我们用过迭代器模式）可以看到之前是每个文件对象里面包括了这么多属性那么用享元模式的话要把这些属性分类，抽取出“上传类型”这个内部属性，其他的都归结为外部属性这边借助闭包实现一个共享的对象（也可以认为是一个单例模式的粗陋实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445var Upload = function(uploadType) &#123; this.uploadType = uploadType;&#125;;var UploadFactory = (function() &#123; var createdFlyWeightObjs = &#123;&#125;; return &#123; create: function(uploadType) &#123; if (createdFlyWeightObjs[uploadType]) &#123; return createdFlyWeightObjs[uploadType]; &#125; return createdFlyWeightObjs[uploadType] = new Upload(uploadType); &#125; &#125; &#125;)();var uploadManager = (function() &#123; var uploadDatabase = &#123;&#125;; return &#123; add: function(id, uploadType, fileName, fileSize) &#123; //生成对象，+ 外部状态放到一个database里面去， var flyWeightObj = UploadFactory.create(uploadType); //... uploadDatabase[id] = &#123; fileName: fileName, fileSize: fileSize, dom: dom &#125;; return flyWeightObj; &#125;, setExternalState: function(id, flyWeightObj) &#123; //给单利对象挂靠外部属性，其实是替换外部属性 // internalObj = // &#123; // uploadType: 'html5', //不变的部分 // // filename // filesize // dom //若干个对象各自有的，在循环中是不断替换的 // // &#125; var uploadData = uploadDatabase[id]; for (var i in uploadData) &#123; flyWeightObj[i] = uploadData[i]; &#125; &#125; &#125;&#125;)(); 除此之外，需要注意的是，享元状态可以只有外部状态（内部状态只有一个），这个时候实际上就是一个单例模式。 另，还有一种不区分内外状态的对象池，可以用于DOM节点的回收和创建。 状态模式之前我们说过利用鸭子类型来避免if-else的反复code，是将接口/函数的不同转变为对象的多态性，这边要介绍的状态模式则是把状态封装成类，状态中的同一接口函数定义了状态的切换。 每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部，每次状态变化时把请求委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为。 调用的时候直接是 12this.obj.setState(someState)this.curState.someAction() 也就是说每个状态类需要实现同样的接口，由于跟模板方式中我们介绍过的一样，JavaScript直到执行时才会报错，（throw error）。 其实想一下，Vue或者react中就有状态模式的概念，react中直接就是state对象，每次都去setstate切换状态，去重新渲染，切换状态后又会有新的行为，就是这个状态下的操作。Vue中对应的大概就是data对象了，只不过这个状态模式我们感受的不太明显，地表以上对开发人员透明的感觉。 状态模式与策略模式 策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，之间的切换是由用户手动操作的。 状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，被封装在了状态类内部，对客户来说，并不需要了解这些细节。这正是状态模式的作用所在 其他设计原则： 单一职责原则：代理模式、装饰器模式、迭代器模式（回调函数）、单例模式（通用的创建移到外部） 最少知识原则（迪米特法则）：应当尽量减少对象之间的交互。常见的做法是增加一个中间人，如中介者模式 ，去管理他们之间的关系。 外观模式 中介者模式 作用域也是广义的最少知识原则的体现，限定在一个小区域内known 开放封闭原则： 可扩展，但不允许修改 对象的多态性代替分支 在变化的地方放置hook，回调 设计模式中的实践： 发布-订阅模式（增加订阅者不需要改动发布者内部函数） 模板方法模式：（增加子类） 策略模式 代理模式（本体实现基本的功能不动就好） 职责链模式 前辈总结的这些设计原则通常指的是单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、合成复用原则和最少知识原则。 代码编写时的建议： 提炼函数 合并重复的条件片段 分支条件语句提炼成函数便于调试 合理使用循环（迭代器模式）代替if-else 提前让函数return (如果有多个if-else的haul) 使用object作为参数来代替多个参数（因为会有顺序的问题，当然es6的话还可以解构） 尽量减少参数数量 多条件嵌套时少用三目运算符 分解大型类 to distinguish [ ] 发布-订阅者模式、中介者模式 [ ] 装饰器模式、适配器模式、代理模式 [ ] 享元模式、状态模式 [ ] 模板方法模式与装饰器模式","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"javascript设计模式（二）","slug":"design-principle2","date":"2017-01-31T01:34:58.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2017/01/31/design-principle2/","link":"","permalink":"http://yoursite.com/2017/01/31/design-principle2/","excerpt":"","text":"代理模式 用户不方便直接访问一个对象或者不满足需要的时候，通过另一个对象B去进行代理控制访问。对用户来说，能操作的就是B，B再来转交请求给target，而不用用户来管B-&gt;target到底做了什么操作。 最朴素的代理模式就是下面的代码，只是做一个转发请求 1234567891011121314151617181920（function()&#123; var Flower = function()&#123;&#125; var xiaoming = &#123; sendFlower:function(receiver)&#123; var flower = new Flower() receiver.receiveFlower(flower) &#125; &#125;, var proxier = &#123; receiveFlower: function()&#123; //当然这边只是代理操作，实际上可能还会有保护检查，拒绝，性能优化等操作 target.receiveFlower(flower) &#125;; &#125;, var target = &#123; receiveFlower: function()&#123; console.log(\" i receive the flower, thx!\"); &#125;; &#125;&#125;） 保护代理和虚拟代理代理模式分为两种，按照他们的功能来分类： 一种是做保护target的用途，接受sender的请求，然后进行一些校验，即保护代理，比如上面的代码就是保护代理。 另一种是把一些开销大的操作延迟到真正需要它做的时候再处理，而sender本身不动，依然做最朴素的操作，代理去做优化措施，这种是虚拟代理。 两者的调用不太一样，前者是sender.sendTo(proxy),后者是proxier.call(fn). 日常接触的基本都是虚拟代理，（需要注意的是它的本体和代理要实现同样的方法，即接口要一致，这样才可以对用户透明，也方便调用，但JavaScript不像静态类型语言，不会进行编译检查，因此，只能在最末端进行throw异常抛出，但这个时候已经是执行期了，有一丢丢晚。） 他的用途有比如实现图片预加载、合并http请求、 图片预加载 [备注]：图片预加载的原理是预先设置一个占位图片，当真正的图片资源加载完后去进行替换操作。有一点点像ajax请求获取前放置一个loading层，数据返回后hide loading，显示最终的网页信息。 12345678910111213141516171819202122var myImage = (function()&#123; var imgNode = document.createElement( 'img' ); document.body.appendChild( imgNode ); return &#123; setSrc: function( src )&#123; imgNode.src = src; &#125; &#125;&#125;)();var proxyImage = (function()&#123; var img = new Image; img.onload = function()&#123; myImage.setSrc( this.src ); &#125; return &#123; setSrc: function( src )&#123; myImage.setSrc( 'file:// /C:/Users/svenzeng/Desktop/loading.gif' ); img.src = src; &#125; &#125; &#125;)();proxyImage.setSrc('realImage.png') 这边用代理的一个原因是遵守了单一职责原则，因为setSrc和设置预加载图片是两个职责，通过代理，让myimage只进行设置图片源的功能。做了任务分离。而且，后面我们会提到的性能优化（如缓存）的代理，也是这样，源请求者只做他本身要做的部分，后续的优化功能让代理来实现。（唔，也符合开放-封闭职责…）确切的说，大多数情况下，若违反其他任何原则，同时将违反开放-封闭原则。 合并http请求原理是设置一个代理函数，（利用闭包放置一个Cache[],存放给定时间段内的请求，当时间到达时，一同发送） 123456789101112131415161718192021//本体sendAjax(req);//代理var proxyAjax = (function()&#123; var reqQueue = []; return function(req)&#123; reqQueue.push(req); if(timer) return; //1 timer = setTimeout(function()&#123; //把reqQueue的请求内容合并，比如原始req的post body是[obj1,obj2,obj3].现在要通过一定的方式去合并成一个大的bigObj,然后发送它。 var assignedObj = transform(reqQueue); sendAjax(assignedObj); reqQueue = []; timer = null;//下一轮进来的入口条件,见1处 &#125;); &#125;&#125;)();for(var i=0;i&lt;reqs.length;i++)&#123; proxyAjax(reqs[i]);//楼主之前担心闭包，想了下，以前是在这边进行绑定事件，事件执行时间不定，所以要闭包把i穿进去，但是这边是直接进行操作。所以不要担心。。。。：）&#125; 上面的代码特别是proxy的内部代码要仔细体会下，跟楼主之前写节流的代码思想一致，但是比较巧妙，不需要进行gap时间的计算。po一下节流： 还有一点是，这边的合并请求跟之前的节流有点思想相似，只不过这边是特定场景的优化，节流是通用的对函数的操作。合并请求的优点很多，可以缓解服务端压力，而且当用户发送请求后又取消时，合并以后实际上是不发送请求的。当然这也可以在前端判断… 其他优化场景除此之外，代理还可以进行其他缓存操作，比如： 动态规划里面的缓存数组= = ajax请求的数据这样使得本体函数可以只进行自己的操作，在代理中做完优化后直接sourceFun.apply()就可以了。 【summary】代理分保护和虚拟代理，虚拟代理的使用场景是一些大型开销操作或者优化措施，case有预加载，合并请求，ajax数据缓存等等。 迭代器模式 只要被迭代的对象有length属性并且可以用下标访问，就可以被迭代。 书里面说迭代器分为两种： 一种是内部迭代器，也就是说函数内部定义好了如何去进行迭代，如js原声的forEach,map等等，underscore里面也有实现 12345678var each = function(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; fn.call(null,arr[i],i,arr); &#125;&#125;each([1,2,3],function(v,index)&#123; console.log(v)&#125;); 另一种是外部迭代器，即把所有遍历操作等等都放权给程序员，比如遍历规则是什么，比如step，何时终止等等，有点像java里面的iterator。之前看到es6里面也有简易版本的iterator，只要实现遍历器生成方法就行。 123456789101112131415161718192021const obj = &#123; [Symbol.iterator] : function () &#123; return &#123; next: function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;;//[Symbol.iterator]()返回的是一个遍历器对象。如果一个对象实现了它，并且index是数字，那么它也可以被用iterator遍历。可以用for of来访问值。 var $iterator = ITERABLE[Symbol.iterator]();var $result = $iterator.next();while (!$result.done) &#123; var x = $result.value; // ... $result = $iterator.next();&#125; 使用场景如代替if-else，上传方式的遍历：（浏览器上传控件、flash上传、原生表单上传input file）示例代码： 12345678910var iteratorUploadObj = function()&#123; for ( var i = 0, fn; fn = arguments[ i++]; )&#123; var uploadObj = fn(); if ( uploadObj !== false )&#123; return uploadObj; &#125; &#125;&#125;;var uploadObj = iteratorUploadObj( getActiveUploadObj, getFlashUploadObj, getFormUpladObj ); 【summary】迭代器分为内部、外部两种类型。迭代器遵循了单一职责模式，将遍历data的职责与其他的操作分离开（用回调）。 模版方法模式广义的模版方法模式主要是由抽象父类和具体实现父类方法的子类组成，父类中定义了方法，主要有两种： 抽象方法： 需要字累实现的方法，包括模版方法：子类方法的执行顺序 具体方法： 从子类中抽取的公共的方法，作复用 123456Coffee.prototype.init = function()&#123; this.boilWater(); this.brewCoffeeGriends(); this.pourInCup(); this.addSugarAndMilk();&#125;; 这边的init方法就是模版方法，因为它规定了子类需要实现的方法及执行顺序。对于javscript来说，没有抽象类的概念，一般用原型链来模拟父类子类。 1234567var Rectangle = function (id, x, y, width, height) &#123; Shape.call(this, id, x, y); this.width = width; this.height = height;&#125;;Rectangle.prototype = Object.create(Shape.prototype);//继承父类的方法Rectangle.prototype.constructor = Rectangle; 注意点 但是有一个问题是，由于javascript是动态语言，没有编译器检查子类是否实现了父类的方法，解决方案一种是在父类里面抛出异常，子类没有实现的话，会顺着原型链调用到父类方法，抛出异常就会发现。 钩子函数： 有时候并不一定按照父类的顺序或者定义的模版方法来执行，需要有所变化，这个时候需要在父类挂一些钩子函数，让这些子类决定的钩子函数来决定子类真正的实现流程。 123456789101112131415Beverage.prototype.init = function()&#123; this.boilWater(); this.brew(); this.pourInCup(); if ( this.customerWantsCondiments() )&#123; // 如果挂钩返回true，则需要调料 this.addCondiments(); &#125;&#125;CoffeeWithHook.prototype.customerWantsCondiments = function()&#123; return window.confirm( '请问需要调料吗？' ); &#125;;var coffeeWithHook = new CoffeeWithHook();coffeeWithHook.init(); 实际上可以用高阶函数的方法，子类把要覆盖的方法作为param传给父类的函数，然后类似于object.assign去生成一个子类的方法集合对象。 嗯，react中的HOC（高阶组件）有点像这边的父类，好吧，本质上跟继承没差啦。 外观模式外观模式对客户提供一个简单易用的高层接口，高层接口会把客户的请求转发给子系统来完成具体的功能实现。概况来说就是：客户-&gt;高层接口-&gt; 子系统(内心OS，感觉有点像反向代理…)","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"代理模式","slug":"代理模式","permalink":"http://yoursite.com/tags/代理模式/"}]},{"title":"读书笔记——白帽子讲web安全（一）","slug":"web-secure1-md","date":"2017-01-30T06:07:28.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2017/01/30/web-secure1-md/","link":"","permalink":"http://yoursite.com/2017/01/30/web-secure1-md/","excerpt":"","text":"防止挂马 客户端沙箱（浏览器保护自己）通常会有恶意代码注入的问题，为了解决”挂马”对浏览器的影响，浏览器有两种解决方法:sandbox + 多进程。 浏览器将不被信任的用户代码（用sandbox包裹）与浏览器内核进程隔绝开，只通过IPC通道访问。 每一个tab页都是一个进程，多进程可以防止某一个崩溃，整个浏览器就崩溃的问题，提升了用户体验。 恶意网址拦截（浏览器保护用户） 恶意网址包括： 挂马网站 钓鱼网站 通常情况下，挂马可能有两种，一种是直接嵌入代码，一种就是恶意网址链接（通过script指向恶意网址）。其实后者是前者的前一步。拦截的方法主要是：浏览器定时从服务获取黑名单匹配。 （而不是浏览器去进行匹配操作，一方面是因为匹配操作放在浏览器，那么攻击者是可以分析解决的，另一方面，数据量过大） 除此之外，还有EVSSL证书（全球证书颁发机构与浏览器厂商的增强型证书），比普通的https还要显著。 跨站脚本攻击XSS payload Cookie劫持 document.cookie访问后，可以伪造发包，然后模拟登录，然后就可以获取更多的信息了。 解决：httpOnly不许通过脚本访问cookie。即cookie可以被自动被发送，但是无法获取 1Set-Cookie: USER=123; expires=Wednesday, 09-Nov-99 23:12:40 GMT; HttpOnly 其他要攻击者多做的事情包括： 图片验证码.(黑客：可以把图片url发往远程服务器去解析) old password：钓鱼 收集信息 识别用户浏览器： navigator.userAgent(不太准确，因为userAgent可以伪造) 分析浏览器独特特征，来进行匹配 【学者Gareth Heyes】 识别安装软件、插件、扩展： 通过识别是否安装某控件来判断 是否有某软件的classId来判断扫描Plugins列表，Extension（比如某扩展如果装了就可以显示某个图标，那么放一个src=图标的url，看是否显示） XSS构造技巧 绕过长度限制： 放event事件中（少了”script”） location.hash中写（而不是input中） 利用注释符，把input注释掉，在后面放script 1234567&lt;input id=1 type=&quot;text&quot; value=&quot;&quot; /&gt;xxxxxxxxxxxxx&lt;input id=2 type=&quot;text&quot; value=&quot;&quot; /&gt;在第一个input框中，输入：&quot;&gt;&lt;!--在第二个input框中，输入：--&gt;&lt;script&gt;alert(/xss/);&lt;/script&gt;最终&lt;input id=1 type=&quot;text&quot; value=&quot;&quot;&gt;&lt;!--&quot; /&gt; xxxxxxxxxxxxxxxxx &lt;input id=2 type=&quot;text&quot; value=&quot;--&gt;&lt;script&gt;alert(/xss/);&lt;/script&gt;&quot; /&gt; 4. 使用base：把本页面的所有相对路径，都附上base指向的恶意网址。然后在恶意网址的服务器中构造相应的路径。 5. window.name 可以在两个域传输数据 - 变废为宝： apache expect (可注入) 防范XSSHttpOnly服务器发送指示，要求set-Cookie中某一个cookie httpOnly。那么浏览器会设置所有的cookie。但是设置了httpOnly的cookie是不能被访问的。通过TRACE请求可以绕过这个，它的responseBody里面会返回cookie. 输入检查 看是否包括有害特殊字符，匹配XSS特征等 XSS-filter（但是某些转义可能会违背用户本意） 输出检查escape编码，但是其实也不一定能满足需求。要分场景。 根本解决方案：列出场景，逐一解决： html: htmlEncode script中：保证所有变量都在“”双引号中。 事件中： javascriptEncode ![](http://p1.bpimg.com/567571/1236b29deaada5b0.png) css中：尽可能禁止用户输入变量放在style标签中，用encodeForCSS() 地址（url）中:URLEncode 富文本（用户自定义的html）:禁止“事件” Dom based XSS 首先，在$var输出到&lt;script&gt;时，应该执行一次javascriptEncode；其次，在document.write输出到HTML页面时,要分具体情况看待：如果是输出到事件或者脚本，则要再做一次javascriptEncode；如果是输出到HTML内容或者属性，则要做一次HtmlEncode。 csrf在b.com域名下，有一个img，src为a.com域名下的某个请求A，黑客先诱导用户登录a.com。由于在同一个浏览器下同一个域名的tab页面是共享cookie的，因此A中是携带了cookie的。那么用户访问b页面时，间接访问了a，就达到了跨域执行a页面请求的目的。（第三方cookie）在某些浏览器下，第三方cookie是被禁止的，比如ie,可以避免csrf。但是由于p3p的出现，使得第三方cookie可以被发送，csrf。 P3P Header是W3C制定的一项关于隐私的标准，全称是The Platform for Privacy Prefer-ences。如果网站返回给浏览器的HTTP头中包含有P3P头，则在某种程度上来说，将允许浏览器发送第三方Cookie。 它的防御有 验证码： 因为csrf往往在用户不知情的情况下进行操作，用验证码就是让用户对自己的请求操作知晓、负责。 Referer Check在互联网中最常见的应用就是“防止图片盗链”。用来验证发送请求的页面是否是应有的页面，或者是否是在同一个域名下。比如之前的b中iframe中有a的请求，它的referer就是b。但是服务端有时候是不能获取到referer的。由于隐私设置等等。 token：一个仅被浏览器与服务器知晓的随机数，每次请求时都需要携带这个token信息来验证身份。（使得攻击者无法知晓token，无法发送请求）。 1http://host/path/delete?username=abc&amp;item=123&amp;token=[random(seed)] 因为csrf请求的前提是攻击者要知道完整的url，如果用token的话，就需要提前知道这个token。而token的获取是随着页面生成/打开才生成的。（可以理解为执行生成，非编译时）。攻击者给出来的只是链接非页面，它无法知道token。所以请求无法构造。但是如果嵌入的是iframe...= =。 具体来说是，每次打开某个请求页面，服务器都会返回一个token，（可以是后端渲染前端页面时直接嵌进表单，如下图）。 然后表单请求的时候，服务端读取这个token，跟后端session中的token比对，验证表单是否可信。(实际上，比对可以是前端跟后端，也可以是前端跟前端，就是表单跟cookie比对，因为后端存session中的话是需要消耗一定资源的，如果直接放在cookie中可以减少消耗，在仅仅csrf攻击，不涉及其他的情况下，cookie是不能被更改的，那么验证表单跟cookie中token===表单与session中token)。 还有几个注意事项是： - token生命周期，为了使用方面，可以在某个时间段内都使用同一个token，但是一提交表单就应废弃一个token。 - 多个相同页面打开时，如果一个消耗完，其他页面要相应的同步，或者设置几个同时有效的token。 - token应该避免存在url中，（应尽量放在表单中），否则可以由referer被泄露。 - 尽量用post代替get，因为get请求的话参数会被暴露到url中，就可能暴露表单提交中的token。 why it works? - 难猜到 - 难获取：攻击者需要通过某种手段获取你站点的CSRF token， 他们只能使用JavaScript来做，但是如果站点不支持CORS，跨域的话，那么他们就没有办法来获取CSRF token。因此确保CSRF token不能通过AJAX访问到。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"白帽子讲web","slug":"白帽子讲web","permalink":"http://yoursite.com/tags/白帽子讲web/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"JavaScript设计模式（一）","slug":"design-priciples1-md","date":"2017-01-30T06:05:31.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2017/01/30/design-priciples1-md/","link":"","permalink":"http://yoursite.com/2017/01/30/design-priciples1-md/","excerpt":"","text":"概述动态语言类型与鸭子类型 javascript是动态类型语言，只有在运行时才会知道变量类型，缺点是运行时可能出现与类型有关的错误，好处是，针对接口编程，不关心它isA，只关心它ｈａｓA，比如，有length，有slice等等的就可以当数组用。(相当于，可能一只会鸭子叫的鸡也会被认为是鸭子…) 多态多态的思想其实是把“做什么”跟“谁去做”分离开来，需要找出各个对象中共有的“做什么”的部分。多态性的根本作用在于把过程化的条件分支语句转化为对象的多态性。javascript由于不用类型检查，与生俱来有多态性。很多设计模式就有多态性的内涵在里面，而javascript的高阶函数也可以用来实现这些设计模式。 123456789var makeSound = function(animal)&#123; animal.sound();&#125;//这样就可以调用// makeSound(new Duck())var Duck = function()&#123;&#125;Duck.prototype.sound = function()&#123; console.log(&quot;嘎嘎嘎&quot;);&#125; 封装包括封装数据、封装方法、封装类型、封装变化。其中 封装数据（访问权限） let限定作用域 闭包 symbol 伪私有属性 封装变化《设计模式》一书中共归纳总结了23种设计模式。从意图上区分，这23种设计模式分别被划分为创建型模式、结构型模式和行为型模式。拿创建型模式来说，要创建一个对象，是一种抽象行为，而具体创建什么对象则是可以变化的，创建型模式的目的就是封装创建对象的变化。而结构型模式封装的是对象之间的组合关系。行为型模式封装的是对象的行为变化。 原型系统javascript遵守原型编程的基本原则： 所有的数据都是对象 除了undefined以外，所有数据都是对象（当然基本类型的那几种也可以通过包装类的方式得到对象），根对象都是Object.prototype。 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它（Object.create(proto)） 可以通过Object.getPrototypeOf来获取原型。 是通过new运算符进行的操作，可以用ObjectFactory函数来模拟这一操作。 1234567891011121314function Person(name)&#123; this.name = name&#125;Person.prototype.getName = function()&#123; return this.name;&#125;var objectFactory = function()&#123; var obj = new Object(); //1 var Constructor = [].shift.call(arguments); obj._proto_ = Constructor.prototype //！！指向原型 //2 var ret = Constructor.apply(obj,arguments); //3 return typeof ret==='object'? ret: obj; //4&#125;var person = objectFactory(Person,'luchen') 分别对应于以下四个步骤： 用new调用一个函数发生了这些事： （1）新建一个对象 instance=new Object(); （2）设置原型链 instance.__proto__=F.prototype; （3）让F中的this指向instance，执行F的函数体。 （4）判断F的返回值类型： 如果是值类型，就丢弃它，还是返回instance。 如果是引用类型，就返回这个引用类型的对象，替换掉instance。 作者：何幻 链接：https://www.zhihu.com/question/36440948/answer/71234418 来源：知乎 著作权归作者所有，转载请联系作者获得授权。 new操作的等价为： 克隆一个object对象，并把它指向正确的原型，并设置它的内部属性等其他操作。 对象会记住它的原型通过对象的_proto_来记住原型。在创建这个对象（new）的时候就建立了这么一条链。 但是也不是说原型就固定了，它可以动态的指向别处 1A.prototype = obj 如果对象无法响应某个请求，会把这个请求委托给他的[构造器的]原型 查找属性时，先通过对象的_proto_来委托到该对象的构造器的原型（A.prototype）上，而A.prototype在上面被指向为obj，那么就从obj来查找属性。 obj -&gt; obj._proto_= A.prototype -&gt;objB 虽然es6中有类的概念了，但本质还是用的原型链，看es6 feature里面的对比 1234567891011121314151617181920212223242526272829303132333435363738//es6class Shape &#123; constructor (id, x, y) &#123; this.id = id this.move(x, y) &#125; move (x, y) &#123; this.x = x this.y = y &#125;&#125;//继承class Rectangle extends Shape &#123; constructor (id, x, y, width, height) &#123; super(id, x, y) this.width = width this.height = height &#125;&#125;//es5var Shape = function (id, x, y) &#123; this.id = id; this.move(x, y);&#125;;Shape.prototype.move = function (x, y) &#123; this.x = x; this.y = y;&#125;;//继承//继承属性var Rectangle = function (id, x, y, width, height) &#123; Shape.call(this, id, x, y); this.width = width; this.height = height;&#125;;//这边是继承方法Rectangle.prototype = Object.create(Shape.prototype);//因为重写原型链了，所以constructor会丢失，要再补上Rectangle.prototype.constructor = Rectangle; new运算符的精髓在与_proto_的挂载，继承的精髓在于属性和方法的复制，方法的复制可以用Object.create，然后重写原型链，但重写后会导致constructor丢失，因此要找回来。具体的可以回头再看下高程… thisthis的若干种场景，在楼主的某篇blog里面已经说过了。比较好的代码片段 123456789101112document.getElementById = ( return function(func)&#123; return func.apply(document,arguments) &#125;)(document.getElementById);//实现bindFunction.prototype.bind = function(context)&#123; var self = this; //保存当前函数 return function()&#123; self.apply(context,arguments); &#125;&#125; 闭包和高阶函数用处： 封装变量 延续局部变量的寿命 12345678var mult = (function()&#123; var privateParam = &#123;&#125;; return function()&#123; privateParam[key] = someValue; return privateParam &#125;&#125;)mult() 命令模式是把请求封装成对象，从而分离请求的发起者和请求的接受者（执行者）之间的耦合关系·用闭包可以事先往命令对象中植入命令的接收者。虽然闭包使得局部变量可以长期被引用，一直生存下去，但一般来说它不会导致内存泄露，要回收的话只需要设置null即可。与内存有关的地方是比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，那就可能造成内存泄露，但这是由于IE浏览器中BOM和DOM是使用C++用COM对象的凡是实现的，它的垃圾回收机制是引用计数，循环引用会导致无法被回收，所以内存泄漏。 经典闭包 1234567for(var i=0;i&lt;nodes.length;i++)&#123; (function(i)&#123; node[i].onclick = function()&#123; console.log(i); &#125; &#125;)(i)&#125; 高阶函数 高阶函数是至少满足以下条件的函数：参数为函数返回值为函数 参数为函数： ajax回调、Array.prototype.sort函数 返回值为函数：常见的为单栗模式，具体的可以看之前的博文第八条 还有一段很不错的代码片段： 1234567function isType(type)&#123; return function(obj)&#123; return Object.prototype.toString.call(obj)===`[object $&#123;type&#125;]`; &#125;&#125;var isArray = isType('Array')isArray([1,2,4]) 高阶函数的其他场景还有： currying 之后我们看函数式编程会涉及到，具体再看 函数节流（之前我们讲过） 惰性加载（首次嗅探后函数覆盖） 123456789101112function createXHR()&#123; if（typeof XMLHttpRequest != 'undefined'）&#123; createXHR = function()&#123; new XMLHttpRequest(); &#125; &#125;else if(typeof ActiveObject != 'undefined')&#123; createXHR = function()&#123; ... &#125; &#125;else ... return createXHR();&#125; 分时函数（一次往页面上大量添加dom节点会让浏览器卡顿，可以用settimeout分多次进行操作） 设计模式1. 单例模式 js中单例模式的核心是：确保只有一个实例，供全局访问。 1234567//单例var Singleton = (function()&#123; var param; return function(initialValue)&#123; return param || (param = initialValue); &#125;&#125;)(); 全局变量不是单例，但常被用作单例，但会造成命名空间的污染，有以下几种方式可以降低污染： 使用命名空间 1234var a = &#123; someSpace1: &#123;&#125;, someSpace2: &#123;&#125;&#125; 使用闭包封装私有变量 123456var func1 = function()&#123; var privateParam; return function()&#123; //... &#125;&#125; 1.1 惰性单例使用时才创建，而不是一运行/加载页面就创建。比如登录窗口，通常的做法是一开始就隐藏，使用时display:block。但很可能一直用不到。改进的方法是onclick的时候创建，但是维持的需要保证是同一个变量，就可以用之前的闭包来进行判断。 12345678910111213141516171819//惰性单例var generateLoginBox = (function()&#123; var div; function createDiv()&#123; var div = document.createElement('div'); div.innerHTML = \"登录窗口\"; document.body.appendChild(div); return div; &#125; return function()&#123; return div || (div = createDiv()); &#125;&#125;)(); document.getElementById(\"loginBtn\").addEventListener(\"click\",function()&#123; var div = generateLoginBox(); div.style.display = 'block';&#125; 但实际上上述代码中管理单例的跟创建对象的进行了耦合（即这个单例可以用来创建很多类型的单例，不光是div,还可能是其他的image等等）。因此需要进行拆分 123456789101112131415161718function createDiv()&#123; var div = document.createElement('div'); div.innerHTML = \"登录窗口\"; document.body.appendChild(div); return div; &#125;//朴素的改进，一步生成结果var generateSingle = (function()&#123; var result; return function(fn)&#123; return result || (result = fn.apply(this,arguments)); &#125;&#125;)();document.getElementById(\"loginBtn\").addEventListener(\"click\",function()&#123; var div = generateSingle(createDiv); div.style.display = 'block';&#125; method2：生成函数的函数 12345678910111213//管理单例的函数！var generateSingle = function(fn)&#123; var result; return function()&#123; return result || (result = fn.apply(this,arguments)); &#125;&#125;document.getElementById(\"loginBtn\").addEventListener(\"click\",function()&#123; var createSingleDiv = generateSingle(createDiv); var div = createSingleDiv(); div.style.display = 'block';&#125; 类似的场景还包括对dom元素绑定事件，实际上只要在最开始创建的时候绑一次就好。 【summary】全局+命名空间-》单例-》惰性单例（管理单例的代码与创建对象的会耦合）-》带有代理的惰性单例 策略模式 js中策略模式的核心是：定义一系列可以互相替代的算法，把他们分别封装起来。在js中表现为一个strategy对象 程序需要包括两部分，一个是接受用户请求并进行分配的总调度部分，一个是各策略计算部分。如 12345678910111213141516//调度部分Contextvar calculateBonus = function(salary,level)&#123; return strategies[level](salary);&#125;//策略计算部分var strategies = &#123; 'A': function(salary)&#123; return salary*3; &#125;, 'B': function(salary)&#123; return salary*2; &#125;, 'C': function(salary)&#123; return salary*1; &#125;&#125; 还有其他栗子如，缓动动画和表单校验： 对于缓动动画来说，策略就是集结了众多” 根据time,起终点等信息最终计算位置的函数”策略的对象。 对于表单校验，后面我们会提到，表单校验也涉及到装饰器模式（在不改动原有代码的基础上，先进行validate 的before校验，返回值正确后再提交）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var strategies = &#123; noEmptyName:function(name,errMsg)&#123; if(!name) return errMsg; &#125;, minLength: function(value,length,errMsg)&#123; if(value.length&lt;length) return errMsg; &#125;, isMobile: function(phoneNum,reg,errMsg)&#123; if(!reg.test(phoneNum)) return errMsg; &#125;&#125;function Validator()&#123; this.validateQueue = [];&#125;/** * [validator.add()] * @param &#123;[type]&#125; item [description] * @param &#123;[type]&#125; rules [description] */Validator.prototype.add = function(item,rules)&#123; var ruleFuncs = rules.map(function(rule)&#123; var strategyArr = rule.strategy.split(':'); var strategy = strategyArr.shift(); strategyArr.unshift(item); strategyArr.push(rule.errorMsg); return function()&#123; return strategies[strategy].apply(null,strategyArr); &#125;; &#125;) this.validateQueue = this.validateQueue.concat(ruleFuncs);&#125;Validator.prototype.start = function()&#123; return this.validateQueue.every(function(fn)&#123; var errMsg = fn(); if(errMsg) &#123; console.log(errMsg); return false; &#125; return true; &#125;)&#125;var validate = function()&#123; var validator = new Validator(); var form = &#123; username: 'luchen' &#125; validator.add(form.username, [&#123; strategy: 'noEmptyName', errorMsg: '用户名不能为空' &#125;, &#123; strategy: 'minLength:7', errorMsg: '用户名长度不能小于7位' &#125;]); var result = validator.start();&#125;validate(); ============更新增加了装饰器模式的策略模式 12345678910111213141516171819202122232425262728293031323334353637383940var validate = function()&#123; var validator = new Validator(); var form = &#123; username: 'luchen' &#125; validator.add(form.username, [&#123; strategy: 'noEmptyName', errorMsg: '用户名不能为空' &#125;, &#123; strategy: 'minLength:7', errorMsg: '用户名长度不能小于6位' &#125;]); var result = validator.start(); return result;&#125;// validate()/** * 装饰器模式 */Function.prototype.before = function(beforeFn)&#123; var fn = this; return function () &#123; //装饰器添加validate的before判断 if(!beforeFn.apply(this,arguments)) return; else return fn.apply(this,arguments) &#125;&#125;var submit = function()&#123; //ajax console.log('----ajax----');&#125;;submit = submit.before(validate);//调用submit() 【summary】策略模式考虑用对象简便分配策略，来代替switch及耦合，case还有 计算奖金、缓动动画和表单校验三个例子。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"掉过的坑总得自己填起来","slug":"掉过的坑总得自己填起来-md","date":"2016-10-31T03:32:14.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2016/10/31/掉过的坑总得自己填起来-md/","link":"","permalink":"http://yoursite.com/2016/10/31/掉过的坑总得自己填起来-md/","excerpt":"","text":"1. sort()楼主最近在刷leetcode，写threeSum的时候需要对数组进行排序。但是出来的结果始终不对。调试了以后才发现sort()函数与想象中不太一样: sort()方法：如果省略参数，数组项会**先根据toString()函数将其值转换成字符串**在进行比较，是按UNICODE进行比较的，然后根据这个进行排序。 因此会导致下面的情况产生。 ![](http://p1.bqimg.com/567571/824ec9546b15fd75.png) 为了避免这种情况，需要自定义比较函数 12let arr = [-4,-2,-1];arr.sort((a,b)=&gt; a-b) 2. set of array of array通常我们可以用set来unique一个数组，类似于 1[...new Set([1,2,2,3])] or Array.from(new Set([1,2,2,3])) 但是对于array of array就比较尴尬了..因为js里面数组是对象，两个数组的引用是不一样的。所以当你输入这样的值 1Array.from(new Set([[1],[1]])) 其实是不会起到任何作用的。暂时的搓搓的方法，只能之前用json.stringify处理一遍。 123resultSet.add(JSON.stringify([1,2]));result = Array.from(resultSet).map(a=&gt; JSON.parse(a));","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/tags/开发/"},{"name":"坑","slug":"坑","permalink":"http://yoursite.com/tags/坑/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"FE玩耍专栏(一)","slug":"FE玩耍专栏","date":"2016-10-31T03:25:46.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2016/10/31/FE玩耍专栏/","link":"","permalink":"http://yoursite.com/2016/10/31/FE玩耍专栏/","excerpt":"","text":"1. toggle buttonSee the Pen toggle button via css by lu (@luchen) on CodePen. 小记：有几个重要点呐： input 的id与 label的for属性对应，使得label可以检测input的check事件，否则点label是不能触发check的。 css3中：checked 属性，” + “兄弟选择符。使得可以对选中状态下的label进行css编写 todo 用transform,尽量不用left这些。以达到平滑效果 【done】 确实过渡会平滑很多。 2. scrollbarSee the Pen js实现滚动条 by lu (@luchen) on CodePen. recipe: scrollTop height(div高度) 文档内容高度（如果是普通的box里面的，则ele.scrollHeight） 这边是以一个小的div为例。 如果想全局滚动条，类似于阮一峰es6教程上的那种效果。则应该相应的变为 123$(window).scrollTop()$(window).height()$(document).height() 补充知识： element.scrollTop是滚动过程中文档超出视窗的部分，它的最大值就是document.height-element.height,即为progressbar为100%的时候。两幅图可以说明： 还有一种纯css做的方法CSS only scroll indicator。思路主要就是用一个斜对角的图形，然后z-index =-1，只留出height为比如2px的区域，这样滚动条动时，显示的部分就在慢慢变宽。 3. 模拟操作很久以前我萌还在用jquery的时候，很喜欢用的一个函数是trigger，但是离开了jquery，还有什么方法可以实现同样的问题，楼主一直很困惑…一直到看了mdn的相关api，具体demo请戳自定义事件及触发划重点就是： 123var event = new Event()target.addEventListener(&quot;自定义名称&quot;)target.dispatchEvent(event); See the Pen trigger event by lu (@luchen) on CodePen. references: 创建和触发 events mouseevent 4. css做tab切换todo background-clip: 裁剪，从 border-box开始。 background-origin: 显示图片，从padding-box开始to summary: background详解 css div p(div下的所有子元素，包括孙子), div&gt;p(div的直接子元素中的p)，div+p(div的直接后兄弟,1个)，div~p（div后面的所有p兄弟） 5. slider楼主在开发这部分组件，用的是原生的html5的input中的type=range，实现了这么几个功能： 滑动+tooltip 左侧部分高亮 step滑动 显示step tick基本按照ant-design的接口来写的。但是遇到一个尴尬的问题就是…没有办法实现范围选择…需要重新开发.. recipe:html5 input(type:range)选择器： 6. 无限滚动楼主最近在用vue开发cnode的移动端，首页部分有滚动列表，因为我们之前提到过debounce延缓input框发送ajax联想请求。那么这边我们就需要用throtte去实现无限滚动。（无限滚动的原理就是在滚动事件+分页请求+节流）具体为什么不用debounce，需要体会的是debounce是在停止项某事件或者超过某个限时时才执行一次。滚动并不需要用户在停止scroll才去加载，而是应该在滚动的过程中定时去请求。所以用throtte。throtte的实现是最简单的版本： 12345678910111213141516171819202122function throtte(func,wait,options)&#123; let lastTime = Date.now(); return function next()&#123; const now = Date.now(); const gap = now - lastTime; if( gap &gt;= wait )&#123; func.apply(this,arguments); // if(param===options.terminal) return; lastTime = now; &#125; &#125;&#125;//调用created()&#123; this.fetchPage(1); this.infiniteScroll = this.infiniteScroll.bind(this); window.addEventListener(&quot;scroll&quot;,this.infiniteScroll()); &#125;,infiniteScroll()&#123; return throtte(this.fetchWhenScroll.bind(this),1000);&#125;, 在实现过程中，还有这么几个问题： 楼主最开始的思路：方向检测+缓存。直接在滚动时发送请求(给定page初始值，根据上下滑动方向page++/page–)，同时把每一页的数据存储下来。下次发送请求前，先根据页数判断是否已有缓存。上滑的话，不请求，满足需求。上滑一段时间后下滑，因为该页数已经访问过，数据已有，那么也不请求。满足需求。 所以，现在的关键问题在于：怎么检测这个scroll的上下顺序 查阅了资料，发现普遍是通过前后两次的scrollTop来检测的。楼主写了一个 12345678function isScrollDown(initTop,cb)&#123; const curTop = document.documentElement.scrollTop; let isDown = false; if(curTop&gt;initTop)&#123; isDown = true; cb(curTop); return isDown;&#125; 12345678910111213141516171819202122232425262728//调用，滚动检测fetchWhenScroll()&#123; const isDown = isScrollDown(this.initTop,(curTop)=&gt;&#123; this.initTop = curTop; ); isDown? this.page++ : this.page--; //1，方向检测 this.fetchPage(this.page);&#125;,fetchPage(page)&#123; if(responseDict[page]) return; //2，缓存判断 axios.get(&apos;https://cnodejs.org/api/v1/topics&apos;,&#123; params:&#123; page, ... &#125; &#125;) .then(response=&gt;&#123; if(response.data)&#123; const appendedList = this.getTransformedResponse(response.data); responseDict[page] = appendedList; //3，缓存数据 this.postList = [...this.postList,...appendedList]; &#125; &#125;) .catch(err=&gt; console.log(err));&#125; scrollTop是文档的top=0处位置，到window的top=0位置的间距。具体的可以看上面scrollbar的示意图。但是仔细一想，实际上是有问题的。当下滑时，会不停的page++,fetch serverlist。当文档实际上已经结束时。由于还在滚动，page会继续++。，所以要加一个if(response.data)的判断。如果没有数据，就啥也不干。 第二种思路，是看一篇无限滚动的文章看到的(Debouncing and Throttling Explained Through Examples)。主要原理是检测离底部的距离。当快接近底部时发送请求。 视窗底部距离文档底部的距离：let height = \\$(document).height() - \\$(window).scrollTop() -$(window).height(); 应用场景： 实现回到顶部： scrollTop ===0 检测底部： scrollTop === documentHeight- windowHeight具体的关于scroll，楼主上面的scrollbar里面也有介绍。可以瞄一眼。 12345678910111213141516171819202122232425function check_if_needs_more_content()&#123;//1 const scrollTop = document.body.scrollTop||document.documentElement.scrollTop;//2 const doc = document.documentElement; const name = &apos;Height&apos;; const docHeight = Math.max( document.body[ &quot;scroll&quot; + name ], doc[ &quot;scroll&quot; + name ], document.body[ &quot;offset&quot; + name ], doc[ &quot;offset&quot; + name ], doc[ &quot;client&quot; + name ] );//3 const windowHeight = window.innerHeight || document.documentElement.clientHeight; let distanceToDocBottom = docHeight-windowHeight-scrollTop; if(Math.abs(distanceToDocBottom)&lt;300) return true; return false; &#125;//调用fetchWhenScroll()&#123; if(check_if_needs_more_content())&#123; this.fetchPage(this.page); this.page++; &#125; &#125;, 这种方法的好处在于，避免方向的判断，上滑的时候 distanceToDocBottom实际上是变大的，那么就不需要进行请求。同时由于距离底部的距离限定好，那么从本次加载数据，到下次加载数据，实际上是把本次获得的数据滚动完以后再进行加载的。但是有一点问题是，貌似滑动到最下面的时候会停止，需要上滑一部分才会响应。而且当滚动很多页的时候，distanceToBottom会大于设定的gap。就不会发送请求。待解决。除此之外，因为公式是jquery版本的。楼主试了很多兼容的原生版本，但是都不太对…就暗搓搓的去github上面搜了jquery这部分的源码…捂脸。补充 12345678910111213141516if ( jQuery.isWindow( elem ) ) &#123; return elem.document.documentElement[ &quot;client&quot; + name ];&#125;// Get document width or heightif ( elem.nodeType === 9 ) &#123; doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it. return Math.max( elem.body[ &quot;scroll&quot; + name ], doc[ &quot;scroll&quot; + name ], elem.body[ &quot;offset&quot; + name ], doc[ &quot;offset&quot; + name ], doc[ &quot;client&quot; + name ] );&#125; 优化（todo）： 缓存dom节点。 用raf代替throtte，比较滑动的平滑效果。用debounce对比下效果。 ===2016/11/23 更新楼主的throtte是有点问题的，看了下underscore的函数说明，有两点： lastTime的初始值：api的本意是一调用这个throtte才会设置lasttime,然后在此基础上去进行+wait.而楼主是在创建这个闭包的时候就把lasttime给定义了。也就是说如果let test = throtte(console.log.bind(this,3),3000)。在新建test后立刻test()执行。是不会运行的。因为达不到时间。如果过一段时间test().那么才会执行。违背了立刻执行的本意。 2.原api中有leading,trailing的设置:leading是指一调用test()，是否会立即执行（false表明不立即执行）。trailing是指，(trailing的前提是设置了settimeout，在0-wait内进入的函数都会被取消到最后再执行)。那么是否在最后真正执行，就是靠这个trailing。注意。leaing和trailing是不可以同时设置false的。因为这样的话介个函数永远都不会执行=。=，头尾都拒绝了呢。。。下面po下楼主现在的版本。 next函数中的this丢失，fix 123456789101112131415161718192021222324252627282930313233343536373839404142function throtte(func,wait,options)&#123; let isFirst = true; let funcId,gap,lastTime,duration = 0; const finalOptions = Object.assign(&#123;&#125;,&#123; leading: true, trailing: true &#125;,options); if(!finalOptions.leading &amp;&amp; !finalOptions.trailing) &#123; alert(&quot;不可以同时设置leading,trailing为负&quot;); return; &#125; return function next()&#123; const now = Date.now(); const context = this; if( isFirst || (gap = now -lastTime) &gt;= wait )&#123; //=====更新 2017.1.5 lastTime = now; if(isFirst)&#123; isFirst = false; //leading:false时，不执行，等下一次wait的时间以后 if(finalOptions.leading) func.apply(context,arguments); &#125; &#125; else&#123; // lastTime-lastTime+wait间进入的函数，需要取消。结束再执行 clearTimeout(funcId); //trailing true时才执行。 if(finalOptions.trailing) funcId = setTimeout(function()&#123; func.apply(context,arguments); //!!context lastTime = now; &#125;, wait-gap); &#125; &#125;&#125; css3常用 伪类 :focus :checked :target","categories":[],"tags":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/tags/开发/"},{"name":"好玩的","slug":"好玩的","permalink":"http://yoursite.com/tags/好玩的/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"日常笔记-二","slug":"日常笔记-二","date":"2016-10-31T03:20:47.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2016/10/31/日常笔记-二/","link":"","permalink":"http://yoursite.com/2016/10/31/日常笔记-二/","excerpt":"","text":"JavaScript 和事件划重点就是： 1. 监听事件方法： html内联属性避免使用，因为与html耦合 1&lt;button onclick=&quot;alert(&apos;你点击了这个按钮&apos;);&quot;&gt;点击这个按钮&lt;/button&gt; dom属性绑定缺点：多次绑定是覆盖，非添加 123element.onclick = function(event)&#123; alert(&apos;你点击了这个按钮&apos;);&#125;; 事件监听函数 1234element.addEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;);element.removeEventListener(&quot;click&quot;,funcName,false)//ieelement.attachEvent(&lt;event-name&gt;, &lt;callback&gt;);//event-name: on+name use-capture设为false主要是因为ie不支持捕获阶段的事件响应。所以统一在冒泡阶段处理。 2. 事件代理需要注意的时，事件触发的目标总是最底层的节点。比如你点击一段文字，你以为你的事件目标节点在 div 上，但实际上触发在p,span等子节点上。 事件代理优点： 减少事件绑定，提升性能。 动态变化的 DOM 结构，仍然可以监听。 123456789//原生element.addEventListener(&apos;click&apos;, function(event) &#123; // 判断是否是 a 节点 if ( event.target.tagName == &apos;A&apos; ) &#123; // a 的一些交互操作 &#125;&#125;, false);//jquery$(parent).on(&quot;click&quot;,&quot;a&quot;,function(e)&#123;...&#125;) 3. 停止冒泡这个hin有用呀，特别是用于弹窗的交互上，如果希望点击弹窗以外的部分让弹窗消失，就需要给弹窗设置阻止冒泡 1234567891011var overlay = document.querySelector(&apos;.overlay&apos;); overlay.addEventListener(&apos;click&apos;, function(event) &#123; event.stopPropagation(); &#125;); // Remove the overlay when a &apos;click&apos; // is heard on the document (&lt;html&gt;) element document.addEventListener(&apos;click&apos;, function(event) &#123; overlay.parentNode.removeChild(overlay); &#125;); 4. 其他注意事项 事件回调函数的作用域问题，详见另一篇楼主的博文日常笔记的第2条this总结。 resize事件，相关的timing function: debounce throttle immediate 总结来说，throttle和debounce都是为了限制在某段时间内大量连续的触发某一事件而进行的优化函数，两者区别在于： 前者只是减少触发频率，比如每隔200ms,500ms触发一次，但还是要执行多次的。如mousemove 而后者是某段时间只需要执行一次，把那些同样的操作认为是一次操作的抖动部分，去抖。等不再进行某项操作时（比如滚动）才会去执行它。eg。keydown-&gt;keyup。后者的一个栗子就是 百度首页上input框 监听用户的输入，不需要用户回车才发送请求，而是间隔比如500ms才会发送一次。需要体会的是，并不是每隔500ms就发送一次，因此这边用的是debounce。还有一个栗子就是列表滚动的时候，如果交互是等用户停下来再自动加载那么是debounce,如果是在滚动的过程中一直会自动加载下面的内容，那就是throttle具体的例子可以看 上一篇文章5.及时搜索。等有空，楼主再仔细看下下面的文章，然后po一个在线demo好了。。之前的项目中有用到，但是不太好放到codepen里面… 忘了还有一个immediate..它其实就是debounce，只是把回调中要执行的操作提出来先进行了。debounce中我们可以看到，是先等啊等，等到delta 时间到了，我们才去执行 比如 fetchKeywordList(),但是immediate是先执行，然后再等啊等。有点类似于while(){}和do{} while()。to read : timing controls JavaScript 函数节流和函数去抖应用场景辨析 JS魔法堂：函数节流（throttle）与函数去抖（debounce） Debouncing and Throttling Explained Through Examples 楼主来更新了，打个小广告，之前说的throtte，最近也做了demo,具体是写cnode列表时想实现无限滚动而做的。具体请戳无限滚动 webpack 全局变量配置![](http://p1.bpimg.com/567571/b00272bb9e65ec16.png) 因为项目中很多页面都需要发送ajax请求，不可能在每一页都import axios from ‘axios’。因此需要webpack全局配置一下。补充一下之前开发react项目的几个知识点： 如果只有有限几个import,可以用resolve.alias指定路径，加快搜索速度。 如果想打包的话，但是公用库不想打包进去，可以用externals指定。同时在html里面引用一下外部cdn。其他的芝士看前端外刊，以及这个博客 函数声明 日期格式化1234567891011121314function format(time,fmt)&#123; let dateObj = new Date(parseInt(time)); var o = &#123; &quot;M+&quot;: dateObj.getMonth() + 1, //月份 &quot;d+&quot;: dateObj.getDate(), //日 &quot;h+&quot;: dateObj.getHours(), //小时 &quot;m+&quot;: dateObj.getMinutes(), //分 &quot;s+&quot;: dateObj.getSeconds(), //秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (dateObj.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); for (let k in o) if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length))); return fmt;&#125;","categories":[{"name":"日常阅读笔记","slug":"日常阅读笔记","permalink":"http://yoursite.com/categories/日常阅读笔记/"}],"tags":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/tags/开发/"},{"name":"好玩的","slug":"好玩的","permalink":"http://yoursite.com/tags/好玩的/"}]},{"title":"vue组件学习-upload","slug":"vue组件学习-upload-md","date":"2016-10-31T01:35:54.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2016/10/31/vue组件学习-upload-md/","link":"","permalink":"http://yoursite.com/2016/10/31/vue组件学习-upload-md/","excerpt":"","text":"楼主最近项目结束无所事事=。=，加上之前用element的上传组件，用着有一点点不爽…就试着自己写了下上传组件，啊，写完的心理活动就是，虽然一直吐槽element的upload，但是真正轮到自己写才发现too young =。=。他们还是挺厉害的，特别是生命周期的封装上。回归正题，楼主的组件，参照着element和ant-design的upload api，大致实现了如下功能： 单文件/多文件上传 文件预览，可选预览方式：列表/卡片，卡片主要是针对img（用URL.createObjectURL） progress进度条 代码中实际上有两种： 一种是读到内存，用fileReader的progress事件 还有一种是xhr的upload.onprogress事件 最终进度条是按照post到服务器的进度来显示的） accept 限定所能接受的文件类型 可以支持拖拽上传、粘贴上传 源码请戳upload组件，upload分支哟 1. fileReader内置了几个事件，包括onprogress,onloadstart,onabort,onerror,onload,onloadend等几个事件，其中onloadend类似于finally操作，不管onerror还是onload，结束都会执行。在这边我们需要处理进度条，那么先看onprogress事件。event对象有这么几个有用的属性： lengthComputable：决定浏览器是否可以对进度进行计算 total: 文件大小 loaded:已经上传的大小 result: 读取的结果，以data:url格式，可以用来作为src实现预览功能，当然我们也可以对file对象直接用URL.createObjectURL())来获取实现。 2. 文件上传新版本的XMLHttpRequest对象，传送数据的时候，有一个progress事件，用来返回进度信息。它分成上传和下载两种情况。下载的progress事件属于XMLHttpRequest对象，上传的progress事件属于XMLHttpRequest.upload对象。 12xhr.onprogressxhr.upload.onprogress 要显示进度的话，可以在onprogress事件中获取信息。具体的跟上面一样。主要就是xhr和filereader其实都实现了progressEvent。具体的可以通过给event对象打log看下event.target就知道了。在filereader的onprogress中，e.target就是filereader，所以当freader.onload事件中可以调用e.target.result来获取src实现预览。如下: 12345678//filereader实现预览var reader = new FileReader(); reader.onload = (function(aImg) &#123; return function(e) &#123; //e.target=== reader aImg.src = e.target.result; &#125;; &#125;)(img); 12345678//xhr中显示进度xhr.upload.onprogress = function updateProgress(e)&#123;//e.target===XMLHttpRequestUpload，即xhr.upload对象 if(e.lengthComputable)&#123; e.percent = e.loaded/e.total*100; if(options.onProgress) options.onProgress(e); &#125; &#125;; 3. xhr执行顺序： 12345671. xhr open。打开连接2. xhr send ：在这个过程中，追踪请求xhr当前状态，用xhr.readyState来访问。 - case 0: xhr对象刚被创建，尚未open - case 1: //opened - case 2: // headers_received。收到响应头 - case 3: //loading 下载阶段 - case 4: //done 只有当 responseType 为”text”、””时，xhr对象上才有此属性，此时才能调用xhr.responseText 从上面介绍的事件中，可以知道若xhr请求成功，就会触发xhr.onreadystatechange和xhr.onload两个事件。 一般倾向于 xhr.onload事件，因为xhr.onreadystatechange是每次xhr.readyState变化时都会触发，而不是xhr.readyState=4时才触发。 123456789//onload 当请求成功完成时触发，此时xhr.readystate=4const xhr = new XMLHttpRequest();xhr.onload = function onload()&#123; if(xhr.status&lt;200 ||(xhr.status&gt;=300 &amp;&amp; xhr.status!== 304)) if(options.onError) options.onError(getError(action,xhr)); else options.onSuccess(getResponseBody(xhr)); &#125; 补充一条，xhr.send在xmlhttprequest2中data type其实是可以有formdata的，这个就有利于我们上传文件。它会自动将文件转变为字节流对象，然后后台可以进行解析。如果是单纯的obj data,里面放 file的话，无法传输过去。也没法解析。 4. html5 drag drop 一定要在dragover的处理事件中preventDefault(),否则默认行为是会跳转到另一个页面预览文件的。 获取文件列表: e.dataTransfer.files 不会触发到input的change事件 5. file上传1234&lt;input type=\"file\" style=\"display:none\" id=\"fileInput\" ref=\"fileInput\" multiple @change=\"handleChange\"&gt;&lt;div @click=\"clickToChooseFile\" for=\"fileInput\"&gt; &lt;p class=\"upload-hint\"&gt;支持单文件/多文件上传，请选择image类型&lt;/p&gt; &lt;/div&gt; 1234//模拟input点击clickToChooseFile()&#123; this.$refs.fileInput.click();&#125;, 一般是把input进行隐藏，用另一个自定义样式的div代替它，然后在click事件中去手动click该input。 而监听文件变化的事件 onchange事件的参数是本地新变更（增加的files数组）。 6. 粘贴上传我们需要对items的每一项转化为file对象。 12345const imageFiles = Array.prototype.slice.call(e.clipboardData.items).filter(item=&gt;&#123; return (item.kind == &apos;file&apos; &amp;&amp; item.type.indexOf(&apos;image/&apos;) &gt;= 0); &#125;).map(item=&gt; item.getAsFile()); this.handleFiles(imageFiles); e.clipboardData.items.clear();//实际上是不会生效的 然后就可以继续用之前的方法（URL.createObjURL(file)）读取，预览等等操作。其实它内置了两个方法，一个是getAsFile，一个是getAsString。转换完后会成为blob对象（file也是一个blob对象）。 注意点： 楼主本来是想粘贴完以后清空剪贴板的。但是貌似看了下w3c的文档，只有在read/write mode下才可以进行操作，而read对应于drag event,write对应于drop事件，其他对应于protected mode。 而平时我们所说的比如知乎的剪贴版权信息，则是用e.clipboardData.setData()这些来进行操作的。既然可以set，那么也可以用它来清空。e.clipboardData.clearData(“text”)也可以实现。 references 你真的会使用XMLHttpRequest吗？ HTML5 drag &amp; drop 拖拽与拖放简介","categories":[{"name":"开发日常","slug":"开发日常","permalink":"http://yoursite.com/categories/开发日常/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/组件/"},{"name":"upload","slug":"upload","permalink":"http://yoursite.com/tags/upload/"}]},{"title":"日常笔记","slug":"日常笔记","date":"2016-09-30T09:22:36.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2016/09/30/日常笔记/","link":"","permalink":"http://yoursite.com/2016/09/30/日常笔记/","excerpt":"","text":"这边的笔记主要记载自己看周刊或者不错的文章中的一些good points，或者一些需要注意的点,也加入了自己的一些想法 :) 1.const var let区别 let const的作用域更小，为块作用域（{}）,var为函数作用域。如果是for循环中的let ，如 1234567891011121314var x = 0;for (let i = 0; i &lt; 10; i++) &#123; x += 10; //i只在该作用域存在&#125;try &#123; console.log(i);&#125; catch(e) &#123; console.log( &apos;i does not exist here!&apos; );&#125; 输出为： ‘i does not exist here!’ const只能在声明时初始化，它表示它所代表的引用（可以认为是指针）是不可变的，所指向的内容实际是可以变的。如 12345const a = &#123;&#125;;a[&apos;b&apos;] = 1;const b = [];b.push(1) 三者都会变量提升(hoist),只是var提升时会默认设置初始值 undefined，而let,const不会。因此，如果在声明时没有初始化，然后就去访问值的话，var会报出undefined，而let,const会抛出ReferenceError 1234//类似于介个样子var a;console.log(\"a\",a); //undefineda = 3; 2. this 总结最近写ife的task的时候遇到这么一个问题， 1234567891011121314151617Queue.prototype = &#123; ... bubbleSort:function()&#123; var swap = false,that = this,firstRound = true; var arr = this.queue, i = 1, lastIndexOfNotSortedArr = arr.length-1; var bubbleSortId = setInterval(_runSort,interval); function _runSort()&#123; ... this.render(); //这边的this实际上是window，而不是new出来的对象 &#125;&#125; 记得 你不知道的javascript里面有讲解过，好不容易翻出来一点，回忆一下。 a. 全局/function中的this都指向window对象 b. 显示调用如 a.func()，或者用构造函数新建对象b = new B()时，里面的this 分别指向a,b c. apply,call,bind指向绑定的对象 d. 内部函数中的this指向window 此处就印证了上面的代码中的问题 12345678910还有这样的栗子function Foo() &#123; this.value = 42; this.method = function() &#123; // this refers to the global object console.log(this.value); // undefined console.log(this === window); // true &#125;; setTimeout(this.method, 500);&#125; 补充栗子除此之外，还有一个栗子需要特别注意，对照着看b,d两条。 See the Pen this in event by lu (@luchen) on CodePen. 12345678910111213var element = document.getElementById(&apos;element&apos;);var user = &#123; firstname: &apos;Bob&apos;, greeting: function()&#123; alert(&apos;My name is &apos; + this.firstname); &#125;&#125;;user.greeting(); // attention1: My name is Bob// Attach user.greeting as a callbackelement.addEventListener(&apos;click&apos;, user.greeting);// attention2: My name is undefined attention1处符合b的规则，而attention2中，则实际上是因为：事件绑定函数时，会以当前元素为作用域执行。（虽然楼主最开始以为是把user.greeting函数赋给一个匿名回调函数，function(){} = user.greeting.因此在触发它的时候this其实是丢失了的）。不过测试了下，貌似确实是把this绑在了元素上的。具体看codepen里面this.nodeName。关于这个问题的解决方案有两种： 包裹在另一个匿名函数中 1element.addEventListener(&apos;click&apos;, function()&#123;user.greeting()&#125;); bind user 1234element.addEventListener(&apos;click&apos;, user.greeting.bind(user));//或者一步到位： user.greeting = user.greeting.bind(user); element.addEventListener(&apos;click&apos;, user.greeting); —————— 这是一条栗子分割线 end ————— 具体的解决方案有三种： var that = this bind es6箭头函数，实际上也是用的第一种方法（经babel转译后可以看到，里面是没有this的，是沿用的外部的this）具体见bi项目开发总结第26条 ===更新上面我们说到过元素的事件中this是与元素绑定的，那么如果在事件函数中另外定义的回调函数会丢失this. 123456document.getElementById(&apos;div&apos;).onclick = function()&#123; console.log(this.id); //div var func = function()&#123; console.log(this.id) //undefined &#125;&#125; 如果 var getId = document.getElementById。然后执行 getId(&#39;div&#39;)。会实际上变成调用普通函数getElementById,this就指向了windows,而不是document.因此需要进行绑定document。 12345document.getElementById = ( return function(func)&#123; return func.apply(document,arguments) &#125;)(document.getElementById); 3.中文正则1/\\u4E00-\\u9FA5/ 4.跨域总结在公司开发的过程中其实也遇到过这个问题，是像另一个服务器post请求，是的，坑有两个，一个是跨域，一个是跨域没法用post =。=。但是当时时间紧迫,后端同学不是很会配置，就粗暴的都用jsonp+get解决了 4.1 场景同源策略，出于防范跨站脚本的攻击，禁止客户端脚本（如 JavaScript）对不同域的服务进行跨站调用。跨站调用主要指，只要网站的 协议名protocol 主机host 端口号port 这三个中的任意一个不同，网站间的数据请求与传输（ajax请求）便构成了跨域调用。而用script标签请求和解析则可以正常运作。 有一点需要注意的是，跨域请求并非是浏览器限制了发起跨站请求，而是请求可以正常发起，到达服务器端，但是服务器返回的结果会被浏览器拦截。 更直白一点的解释就是，以钓鱼网站（get服务器数据）为例。ta0bao.com，用户提交信息，那么黑客会发送ajax到taobao.com，然后taobao那边的服务器返回数据，如果没有同源策略的话，这个数据就会被获取到。但是有了同源策略，浏览器那边可以得到这个数据，但是黑客在代码里是得不到的。被浏览器拦截了，就不给你就不给你=。=。 同源只能限制不被获取数据，但是发送其实是限制不了的。比如获取用户的私密信息。比如xss。黑客可以在用户提交信息（加上现在在a.com下）时发送两个ajax,一个给正常的网站（a.com），一个给自己的服务器(b.com)。这个是米有办法阻拦哒，要不然钓鱼网站也不会辣么猖狂…摊手。 这实际上也说明了跨域出现的原因及解决方案（用获取script代替ajax请求） 4.2 解决方案：JSONP JSONP是 JSON 的一种使用模式，可以解决主流浏览器的跨域数据访问问题。其原理是根据 XmlHttpRequest 对象受到同源策略的影响，而 script 标签元素却不受同源策略影响，可以加载跨域服务器上的脚本，网页可以从其他来源动态产生 JSON 资料。用 JSONP 获取的不是 JSON 数据，而是可以直接运行的 JavaScript 语句。json数据被封装在回调函数里，就是所谓的json with padding（json填充） 我们通常会直接用jquery的jsonp的解决方案，用法如下： 123456789requestDict[&quot;update&quot;] = $.ajax(&#123; url: urls.update+encodeURIComponent(JSON.stringify(queriesObj)), type: &quot;get&quot;, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;, jsonpCallback: &quot;handleServerPolyData&quot;,//回调 success: function(serverData) &#123; &#125;, ); 最终发出的url是这样的 1http://bigdata.xiaojukeji.com/hotmap/getHeatmapOverlay?productLine=taxi?callback=handleServerHeatData? 但实际上它是做了一层封装，会有点误导。返回的实际上还是javascript语句，jquery进行了解析，正确时会调用success，同时把里面的数据存为上面的serverData。让你看起来jsonp跟普通的ajax请求没有任何区别。 实际上如果自己实现的话，应该是这样的：server1 请求页面有一个script标签 1&lt;script src = &apos;http://localhost:3001/jsonServerResponse?jsonp=jsonpCallback&apos;&gt;&lt;/script&gt; 或者在代码里手动createElement(“script”)，然后设置src后append到head中。 1234//server1请求页面的js代码只有下面的回调function jsonpCallback(data) &#123; console.log(\"jsonpCallback: \"+data.name)&#125; 12345678910// server2处理请求app.get(&apos;/jsonServerResponse&apos;, function(req, res) &#123; var cb = req.query.jsonp console.log(cb) var data = &apos;var data = &#123;&apos; + &apos;name: $(&quot;#name&quot;).val() + &quot; - server 3001 jsonp process&quot;,&apos; + &apos;id: $(&quot;#id&quot;).val() + &quot; - server 3001 jsonp process&quot;&apos; + &apos;&#125;;&apos; var debug = &apos;console.log(data);&apos; var callback = &apos;$(&quot;#submit&quot;).click(function() &#123;&apos; + data + cb + &apos;(data);&apos; + debug + &apos;&#125;);&apos; res.send(callback) res.end()&#125;) 可以看出，服务端返回的应该是一段立即执行的js代码。 4.3 优缺点 优点：解析快+解决跨域。jsonp中，由于数据是被当成原生的javascript，因此解析和原生的一样快，所以数据传输时，时间（下载+解析）中的解析部分几乎为0 缺点（动态脚本注入引起的）： 不安全 只能get请求 不能设置请求的头信息，也就不能设缓存。也不可以访问请求的头信息 不能失败处理 需要等到所有数据返回才可以访问 针对jsonp不能支持post等请求的问题，解决方案是cors(Cross-Origin Resource Sharing)主要是服务器对响应头进行了处理 12//Access-Control-Allow-Originres.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); reference:前端跨域请求原理及实践 ===2016/11/20更新 本次更新是针对jsonp不能post的问题。之前我们说了可以用cors，这个楼主还没有试过。楼主这次是用前端代理的方法，本质是本地请求本地服务器，本地服务器去做转发，服务器间的转发是没有跨域这个概念的。因此可以解决，而这种方法下，服务端实际上不需要像cors那样进行变更。（场景是，本地开发需要访问另一个域名下的数据）。 具体方法是： vue-cli中，是使用了http-proxy-middleware的中间件（node-http-proxy）进行处理，如下 1234567proxyTable: &#123; &apos;/ip/serverInfo&apos;: &#123; target: &apos;https://cnodejs.org&apos;, //origin,域名部分 pathRewrite:&#123;&apos;^/ip/serverInfo&apos;: &apos;/api/v1/topics&apos;&#125;, changeOrigin: true &#125;,&#125;, webpack中有专门的配置，其实也是利用的http-proxy-middleware 123456789 // In webpack.config.js&#123; devServer: &#123; proxy: &#123; &apos;/api&apos;: &#123; target: &apos;https://other-server.example.com&apos;, secure: false &#125; &#125; 5. 即时搜索监听v-model变化，每次变动就取消上一次请求。当超过500ms的时候就发送搜索请求。 1234567watch: &#123; searchInput(newValue, oldValue)&#123; clearTimeout(timer); if(newValue.trim() !==oldValue.trim()) timer = setTimeout(this.fetchKeywordList,500); &#125; &#125;, 6. cookie.js代码赏析1234567var value = document.cookie.split(/;\\s*/) .map(opt.autoencode ? opt.decode : function (d) &#123; return d; &#125;) .map(function (part) &#123; return part.split(&apos;=&apos;); &#125;) .reduce(function (parts, part) &#123; parts[part[0]] = part[1]; return parts; &#125;, &#123;&#125;)[data]; demo: var arr = [{“id”:3,”zh_name”:”test”},{“id”:5,”zh_name”:””lili}]结果：Object {3: “test”, 5: “lili”} 1234arr.reduce((prev,cur)=&gt;&#123; prev[cur[&quot;id&quot;]] = cur[&quot;zh_name&quot;]; return prev;&#125;,&#123;&#125;)","categories":[{"name":"日常阅读笔记","slug":"日常阅读笔记","permalink":"http://yoursite.com/categories/日常阅读笔记/"}],"tags":[{"name":"奇舞周刊","slug":"奇舞周刊","permalink":"http://yoursite.com/tags/奇舞周刊/"},{"name":"前端博文","slug":"前端博文","permalink":"http://yoursite.com/tags/前端博文/"}]},{"title":"es6 学习笔记(四)","slug":"es6-4","date":"2016-09-27T05:54:03.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2016/09/27/es6-4/","link":"","permalink":"http://yoursite.com/2016/09/27/es6-4/","excerpt":"","text":"proxy用于代理。在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截。就比如客户端与服务器之间的代理服务器。设置了代理后，对原对象的修改直接通过代理就可以。 有点可以类比于标签模板，做了一层处理。 基本用法 new Proxy(targetObj,handler) handler:{一组方法，如get(){},set(){}} 123456789101112131415var person = &#123; name: &quot;张三&quot;&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(&quot;Property \\&quot;&quot; + property + &quot;\\&quot; does not exist.&quot;); &#125; &#125;&#125;);proxy.name // &quot;张三&quot;proxy.age // 抛出一个错误 常用的可以拦截的方法 get/set :拦截属性获取/设置 如 obj.name。set方法可以用于validate- get可以被继承 apply: 拦截函数调用/call/apply函数- 使用 apply (target, ctx, args) 如proxy(1, 2) // 6 proxy.call(null, 5, 6) // 22 construct：拦截Proxy实例作为构造函数调用的操作，比如new obj(…args)。该方法必须返回对象 has(target, propKey)：拦截- propKey in proxy的操作(for in 不影响)， - 以及对象的hasProperty（不区分own）方法，返回一个布尔值。（eg。使用has方法隐藏某些属性，不被in运算符发现） 1234567891011121314151617181920212223242526//摘自ruanyf博客var handler = &#123; get: function(target, name) &#123; if (name === &apos;prototype&apos;) &#123; return Object.prototype; &#125; return &apos;Hello, &apos; + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1,2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo // &quot;Hello, foo&quot; reflect同proxy一样，是es6为了完善对象的操作而新提出的对象。主要做的内容包括： 移除Object某些方法：把原有的一些属于object内部的方法如defineProperty挂到Reflect商 改变Object某些操作：把如 a in obj这种变为函数行为Reflect.has(Object,’assign’) Proxy与Reflect一一对应，proxy的每一个方法，都可以调用Reflect的相应的方法，保证原生方法可以调用。（这个方法其实就是完善了的object方法）","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"es6 学习笔记(三)","slug":"es6-3","date":"2016-09-27T05:51:45.000Z","updated":"2016-09-27T05:53:38.000Z","comments":true,"path":"2016/09/27/es6-3/","link":"","permalink":"http://yoursite.com/2016/09/27/es6-3/","excerpt":"","text":"Set 定义 new Set([1,2,3,4])【注】：添加进的时候，不进行类型转换，内部是在===的基础上进行了补充（NaN===NaN）。因此 5和”5”是两个不同的值两个空对象可以同时加入NaN只能添加一个 用途：数组去重1[...new Set(array)] 方法 操作方法 遍历方法对象的是Object.keys()set是set1.keys(),同set1.values() 123456789101112let set1 = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);//返回值相同for(let item of set1.keys())for(let item of set1.values())for(let item of set1)for (let item of set.entries()) &#123; console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;] 用途 12345678910111213let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x))); 遍历的同时进行改变 12345678// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2)); weakset与set的区别在于，它的成员只能是对象，也就是说，即使是通过new WeakSet(arr)定义的，arr的成员才是weakset的成员，因此如果arr只是【1,2】这种，是不行的。 接受一个数组或类似数组的对象作为参数 方法 操作：比set少clear()方法，没有forEach,没有size属性 遍历：成员不可遍历 不是很明白的点：弱引用 Map比传统的Object更为拓展，key不限于字符串 使用123456var m = new Map()map.set(key,value)//也接受以数组作为参数var m = new Map([[k1,v1],[k2,v2],[]]) 注意 对一个key多次赋值，会覆盖 未知key，返回undefined key与内存地址绑定，所以比较key的时候实际上是按引用来看的 属性和方法set中是add delete clear has.map中是set delete clear get 操作方法 123456789//set 返回map自身，因此可以链式调用m.set(&quot;edition&quot;, 6) // 键是字符串m.set(262, &quot;standard&quot;) // 键是数值m.set(undefined, &quot;nah&quot;) //get 未知则undefinedm.get(&apos;&apos;)//has(key),clear() 遍历方法keys.values() entries() forEach().同set的 12345678for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125; 转数组1234567891011[...map.keys()]// [1, 2, 3][...map.values()]// [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;][...map.entries()]// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]][...map]// [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]] 与其他类型的转换 数组 对象 json具体见教程 weakmap跟weakset差不多 异步及async","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"es6 学习笔记(二)","slug":"es6-2","date":"2016-09-27T05:49:01.000Z","updated":"2016-09-27T05:51:30.000Z","comments":true,"path":"2016/09/27/es6-2/","link":"","permalink":"http://yoursite.com/2016/09/27/es6-2/","excerpt":"","text":"解构赋值从数组或者对象中提取值去对变量/数组赋值被称为解构。 一、数组解构赋值类似于123let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4] 注意点：右边必须为可遍历的结构。 左&gt;右对于没有办法匹配的变量，会被赋值为undefined，数组会被赋为空1234let [x, y, ...z] = [&apos;a&apos;];x // &quot;a&quot;y // undefinedz // [] 为了避免这样，可以考虑给默认值。且一旦右边的值非严格等于undefined，就会覆盖左边的默认值1[x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos; 左&lt;右不完全解构，只取部分值1234let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 二、对象的解构赋值变量必须与属性同名，才能取到正确的值。本质上类似于 1234var &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;//egvar &#123;key1,key2&#125; = &#123;key1:value1,key2:value2&#125;key1 //value1 区分模式和变量 也可以设置默认值 123456var &#123;x,y=5&#125; = &#123;x:1&#125;x //1y //5var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5 不要将花括号写在行首，避免被解释为代码块，用括号包裹即可。 123456var x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error// 正确的写法(&#123;x&#125; = &#123;x: 1&#125;); 三、字符串的解构赋值123456const [a, b, c, d, e] = &apos;hello&apos;;//也可以for (let codePoint of &apos;foo&apos;) &#123; console.log(codePoint)&#125; 数值和布尔值也可以解构 四、用途 交换变量 1[x, y] = [y, x+y]; 从函数返回多个值 1234function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example(); 函数参数的默认值 与for of 配合遍历 123for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125; 模块 字符串扩展 includes/startsWith/endsWith(str,index)index为开始搜索的位置 repeat() 12&quot;he&quot;.repeat(3) //hehehe&quot;he&quot;.repeat(0) //&quot;&quot; 模板字符串见另一个笔记es6笔记（一）模板编译部分见阮一峰笔记 标签模板 跟在函数名后面的模板字符串会被识别为多个参数。- 用途1 可以用来对用户传入的数据进行预处理，比如过滤HTML字符串，防止用户输入恶意内容123456789101112131415161718192021222324252627var message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; var s = templateData[0]; //&lt;p&gt; for (var i = 1; i &lt; arguments.length; i++) &#123; var arg = String(arguments[i]); //sender // Escape special characters in the substitution. s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;) .replace(/&lt;/g, &quot;&amp;lt;&quot;) .replace(/&gt;/g, &quot;&amp;gt;&quot;); // Don&apos;t escape special characters in the template. s += templateData[i]; //templateData[i]这边指has sent you a message.&lt;/p&gt; &#125; return s;&#125;//类似于functionName(strArr,..valuesArr),这边的strArr即为模板字符串中分解出来的所有非变量的字符串所组成的数组。//&quot;templateData&quot; [&quot;&lt;p&gt;&quot;, &quot; has sent you a message.&lt;/p&gt;&quot;]//&quot;arguments&quot; [object Arguments] &#123; 0: [&quot;&lt;p&gt;&quot;, &quot; has sent you a message.&lt;/p&gt;&quot;], 1: &quot;luchen&quot;&#125;arguments = strArr + valuesArr 除此之外，还有一个很神奇的用法，就是可以将普通的javascript转换为其他语言，比如说jsx..,找到jsx函数的实现，然后就可以将一个DOM字符串转为React对象..四国以..123456789jsx` &lt;div&gt; &lt;input ref=&apos;input&apos; onChange=&apos;$&#123;this.handleChange&#125;&apos; defaultValue=&apos;$&#123;this.state.value&#125;&apos; /&gt; $&#123;this.state.value&#125; &lt;/div&gt;` 数值的扩展 0b,0o 二进制八进制写法 123456780b111110111 === 5030o767 === 503//es5parseInt(&quot;111110111&quot;, 2) === 503parseInt(&quot;767&quot;, 8) === 503//转为十进制用Number(str)Number(&apos;0b111&apos;) 原有方法加了Number限定，取消全局函数传统方法先用Number转换，然后判断，而现在不会转换，如果非数值，直接false 12345Number.isFinite() Number.isNaN()Number.parseInt() Number.parseFloat()Number.isInteger()//Number.isInteger(25) // true 25与25.0被认为是同一个数//Number.isInteger(25.0) // true 增加极小值，用于浮点数误差判断Number.EPSILON 整数范围JavaScript能够准确表示的整数范围在-2^53到2^53之间（开区间）现在用Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 12Number.MAX_SAFE_INTEGER === 2**53-1Number.MAX_SAFE_INTEGER === -(2**53-1) Math对象的扩展 Math.trunc()取数的整数部分，截断，非四舍五入。非数值先Number(),不能转则NaN 1234//等于function mathTrunc (x) &#123; return (x &lt; 0 ? Math.ceil(x) : Math.floor(x))&#125; Math.sign()判断符号 三角函数运算 对数运算 指数运算 12**3 ===8 数组扩展对象=》数组 Array.from()将以下两种对象转变为数组 类似数组的对象（array-like object），如arguments，getElementsByTag得到的集合 可遍历（iterable）的对象，如Set Map 任何有length属性的对象，都可以通过Array.from方法转为数组 （1）用法： 1Array.from(arrayLike, x =&gt; x * x); **补充**： 扩展运算符（...）也可以做到。主要是以下场景: 12345function f1(param1,...arr)&#123;//确切的说是rest参数 //arr == [v2,v3]&#125;f1(v1,v2,v3) Array.of()将一组数值转为数组 123 Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1] arr.copyWithin(destIndex,srcStart,srcEnd) 12// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4) arr.find() arr.findIndex主要是由于arr.indexOf比较是基于===全等操作符，那么NaN就不能被找到，因为跟NaN有关的表达式都会返回false.参数为回调函数 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 补充： 1arr.includes(param1,startIndex) //es7 arr.fill()常用语初始化 1new Array(3).fill(7) //[7,7,7] arr.entries(),keys(),values()常与for..of一起使用进行对象遍历 123for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125; 函数的扩展 函数参数默认值只能作为尾参数 rest参数 值-》数组 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 扩展运算符将数组-》逗号分隔的序列不同于rest参数是在形参中，扩展运算符用于函数调用里 123456function add(x, y) &#123; return x + y;&#125;var numbers = [4, 38];add(...numbers) // 42 常用 1234Math.max(...[14, 3, 77])arr1.push(...[13,3,2]) //concat[...arr1, ...arr2, ...arr3][a, ...rest] = list 箭头函数 尾递归-》递归改写,以解决多余的参数的问题（套一层函数/curry/es6默认值）-》优化：循环替代递归(1)返回函数而不是返回函数调用，用链式调用来替代嵌套调用见阮一峰es6(2)memonization存储中间值具体见高性能javascript（p76） 对象扩展 属性、方法的简写 12345678910111213var birth = &apos;2000/01/01&apos;;var Person = &#123; name: &apos;张三&apos;, //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log(&apos;我的名字是&apos;, this.name); &#125;&#125;; 属性名表达式,也可以用来定义方法名 12345let propKey = &apos;foo&apos;;let obj = &#123; [propKey]: true,&#125;; 方法的name属性get/set函数 -》person.firstName.name // “get firstName”匿名函数 (new Function()).name // “anonymous”symbol const key1 = Symbol(‘description’); Object.is在===的基础上补充两点： NaN 1Object.is(NaN, NaN) // true +0 -0不相等 1Object.is(+0, -0) // false Object.assign 浅拷贝，如果源对象的某个key的value是对象，那么复制的是这个对象的引用。 123456var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2tong 同名属性，只会替换，不会添加 只能拷贝自身属性，不能拷贝继承的属性以及不可枚举的属性。 用途： 给对象添加属性 12345class Point&#123; constructor(x,y)&#123; Object.assign(this,&#123;x,y&#125;) &#125;&#125; 给对象添加方法 12345Object.assign(someClass.prototype,&#123; someMethod(arg1, arg2) &#123; ··· &#125;,&#125;) 克隆对象1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin); &#125; 属性的遍历for..in,Object.keys(),Object.getOwnPropertyNames(obj),Object.getOwnPropertySymbols(obj),Reflect.ownKeys(obj) 遍历顺序： 数字（按大小）-》字符串(按生成时间)-》Symbol（按生成时间）12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// [&apos;2&apos;, &apos;10&apos;, &apos;b&apos;, &apos;a&apos;, Symbol()] es7中的Object.getOwnPropertyDescriptorsrest用于对象解构 补充知识ES5有三个操作会忽略enumerable为false的属性。 for…in循环：只遍历对象自身的和继承的可枚举的属性 Object.keys()：返回对象自身的所有可枚举的属性的键名 JSON.stringify()：只串行化对象自身的可枚举的属性 es6中Object.assign():跟Object.keys一样，只拷贝自身的可枚举属性 es6中所有class的原型的方法都是不可枚举的。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"es6 学习笔记(一)","slug":"es6-1","date":"2016-09-27T05:45:47.000Z","updated":"2017-02-01T01:31:58.000Z","comments":true,"path":"2016/09/27/es6-1/","link":"","permalink":"http://yoursite.com/2016/09/27/es6-1/","excerpt":"","text":"概览箭头函数、模板字符串、promise、generator(iter.next去执行yield内容)、class、module 杂记 作用域，用代码块+let 替代IIFE，特别是let可以处理闭包的问题补充见另一篇笔记 1234567891011121314for(let i=0;i&lt;6;i++)&#123; a[i] = function()&#123; console.log(i); &#125;&#125;//es5的实现应该是介样的for(var i=0;i&lt;6;i++)&#123; (function(i)&#123; a[i] = function()&#123; console.log(i); &#125; &#125;)(i);&#125; 2，用模板变量代替字符串拼接 1`$&#123;x&#125;+$(y)` == x+&quot;+&quot;+y 模板字面量可以横跨多行。 空格和换行都会保留 3，函数的默认参数应该在最右边，实参与形参从左开始匹配 4，class 1234567891011121314151617181920//es5function Point(x,y)&#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;&#125;//es6class Point&#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125; toString()&#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125; 注意点： class不存在变量提升，也就是说它的使用必须要在定义后 私有方法： 用 _functionName 把私有方法都放外部，class内部只存暴露出去的公有方法，比如 12345678class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz)&#123;...&#125; 用symbol处理私有方法和属性的名称 123456789101112const privateFun = Symbol(&apos;bar&apos;);const privateParam = Symbol(&apos;bar&apos;);class test1&#123; //私有方法 [bar](param)&#123; //私有属性 this[privateParam] = ... &#125; fun1()&#123; this[bar](&quot;实参&quot;); &#125;&#125; 5， 继承通过extends关键字，继承了父类的所有属性和方法。等于复制了一个Point类123456789101112131415class Rectangle extends Shape &#123; constructor (id, x, y, width, height) &#123; super(id, x, y) //父类构造函数，必须调用，用来新建父类的this实例，同时复制一份作为自己的 this.width = width this.height = height &#125;&#125;//es5function Rectangle(id, x, y, width, height) &#123; Shape.call(this, id, x, y)//复制一份父类shape的属性id,x,y，用自己的值进行初始化 this.width = width this.height = height&#125;Rectangle.prototype = Object.create(Shape.prototype)//深复制父类的原型，然后改变原型的指向，使得子类自己保持一份原型Rectangle.prototype.constructor = Rectangle 6, 静态属性方法 static 函数static方法是被类所调用，实例是没有办法调用的。而且可以被继承 123456789class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod(); // &apos;hello&apos; 静态属性：类有静态属性，但是类内部是不能有静态属性的。只能在外部 12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 实例属性之前是在构造函数中定义实例属性，现在可以放在外部123456789101112131415161718192021class MyClass &#123; myProp = 42; constructor() &#123; console.log(this.myProp); // 42 //以前的写法：this.myProp = ... &#125;&#125;//或者更复杂的是class ReactCounter extends React.Component &#123; newProps = &#123; count:3; &#125;; state; //constructor里面已经定义的实例属性 constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125;&#125; es7中静态属性提案，将静态属性也像实例属性一样放进来1234567class MyClass &#123; static myStaticProp = 42; constructor() &#123; console.log(MyClass.myProp); // 42 &#125;&#125; Module模块化123456789101112131415161718192021var firstName = &apos;mei&apos;;var lastName = &apos;qingguang&apos;;var year = 1988;//exportexport &#123;firstName, lastName, year&#125;;//importimport &#123;firstName, lastName, year&#125; from &quot;./module1.js&quot;console.log(firstName);或者 import * as Module1 from &quot;./module1.js&quot;console.log(Module1.firstName)//整体输出的话//test1.jsexport default function()&#123; ...&#125;import yourModuleName from &quot;test1.js&quot;yourModuleName() //函数执行","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"vue学习前传(二)","slug":"vue-prev-2","date":"2016-09-27T05:36:28.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2016/09/27/vue-prev-2/","link":"","permalink":"http://yoursite.com/2016/09/27/vue-prev-2/","excerpt":"","text":"vue之前的博客里面，我们讲了vue的数据绑定以及它的用法，而由于之前一直用react开发，难免会进行相互比较，那么这一篇就以与react联系的角度来看看vue的一些特性。ps：之前的数据绑定，因为当时公司的版本是旧的，为了继续在前fe的基础上继续写，不得已用的是0.12的版本，今天这篇的版本是1.0：） 组件化props:查看vue component教程，总结来说，它是react props的扩展版本。（1）相同的地方在于：props也是默认单向数据流，从父组件传递属性到子组件。（2）之所以说扩展，体现在两个方面： 扩展一：props in vue == [伪]props in react; 扩展二：props in vue 可单向，可双向绑定数据。 让我们看第一个扩展。 vue的props提供了两种使用方法，静态的+动态绑定。用react的方式来理解的话： props == 子组件默认的不可变属性。 绑定的props== props in react。默认情况下，props只负责传递父组件传给它的属性，且当组件加载后只传递一次，我们可以看到，下面的静态绑定demo中，虽然跟父model同名，但是只解析为字符串，只有变成动态绑定的props，才会解析为从父元素传递下来的变量。每次父组件的相关数据进行变化时，子组件便会随之更改，类似于react中的props. See the Pen vue组件化demo by lu (@luchen) on CodePen. 123456789//html&lt;div class=\"childWrapper\"&gt; &lt;input v-model=\"dynamicMsg\"&gt; &lt;br&gt;&lt;span&gt;静态绑定：&lt;/span&gt; &lt;child parent-msg=\"dynamicMsg\"&gt;&lt;/child&gt; &lt;br&gt;&lt;span&gt;动态绑定到父元素：&lt;/span&gt; &lt;child :parent-msg=\"dynamicMsg\"&gt;&lt;/child&gt;&lt;/div&gt; 1234567891011//javascriptVue.component('child', &#123; props: ['parentMsg'], template: '&lt;span&gt;&#123;&#123; parentMsg &#125;&#125;&lt;/span&gt;'&#125;)var parent = new Vue(&#123; el:\".childWrapper\", data:&#123; dynamicMsg:\"hello\" &#125;&#125;) 注意点： js中的camel写法对应于html中的kebab-case 如果 prop 是一个对象或数组，是按引用传递。在子组件内修改它会影响父组件的状态，不管是使用哪种绑定类型。就变成了双向绑定了 如果props是数组，则需要按照动态绑定来写，使得看成变量、表达式，否则会以字符串传递。===更新2017/1/4 父组件传进来的props作为子组件data的初始值存在的话，如果它变动，内部data是不能响应的，需要设置watch（props），保持data始终在props的基础上变动 再看看第二个扩展react的props是单向数据流，而vue中还可以实现双向的绑定。但是最好还是不要这么做，因为父组件有很多子组件，每个都进行双向绑定的话，会有各种冲突问题，而且光看父组件的信息，很难理解父组件的状态 1&lt;child :msg.sync=&quot;parentMsg&quot;&gt;&lt;/child&gt; 通常是用v-bind来绑定数据，实现js中传值使得数据渲染，在交互频繁的表单上，可以用v-model进行双向绑定。 计算属性也有双向绑定的含义，watch+反向set 双向props示例12//child&lt;modal :category=&quot;category&quot; title=&quot;禁发&quot; :order=&quot;order&quot; :show.sync=&quot;showModal&quot;&gt;&lt;/modal&gt; parent会对showModal这个变量进行变动。 12345//parent button点击响应事件showDetail()&#123; console.log(&quot; ==== &quot;, this.showModal); this.showModal = true; &#125;, 在modal内部 1234567&lt;div class=\"modal\" v-show=\"show\"&gt; //here &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\" @click=\"closeModal\"&gt;&amp;times;&lt;/button&gt; &lt;h4 class=\"modal-title\"&gt;&#123;&#123;category&#125;&#125;&lt;/h4&gt; &lt;/div&gt; 12345678910111213141516export default &#123; name:&quot;PopModal&quot;, props:[&quot;category&quot;,&quot;order&quot;,&quot;show&quot;], //表明从父元素传递下来 data () &#123; return&#123; &#125; &#125;method()&#123;closeModal()&#123; this.show = false; &#125;,&#125; 需要注意的是，如果modal绑定的时候是单向的，即 ：show = “showModal”，那么子组件内部使得show = false的时候，父组件的showModal还是保持true的状态。那么会导致父的状态是显示，子状态是不显示，那么点击 showPop按钮的时候是无法显示的。应该改为双向上。 12//update&lt;modal :category=&quot;category&quot; title=&quot;禁发&quot; :order=&quot;order&quot; :show.sync=&quot;showModal&quot;&gt;&lt;/modal&gt; 开发杂项 scope 限制cssA组件，B组件都引入到组件C中，但是A,B都有同样的样式.class name，那么会冲突，因此需要用scope 去进行限制，而且需要注意的是在style里面进行 import，scope是不起作用的。只能inline css 12345678910111213141516&lt;style lang=&quot;scss&quot; scoped&gt;.modal&#123; display: block; display: flex; align-items:center; justify-content:center; background-color: rgba(11, 11, 11, 0.6); .action&#123; cursor: pointer; &#125;&#125;.modal-dialog&#123; max-width: 30%;&#125;&lt;/style&gt; vue-router 注意事项 1234&lt;ul class=&quot;nav nav-tabs&quot;&gt; &lt;li class=&quot;&quot;&gt;&lt;a v-link=&quot; &apos;/event/list&apos; &quot; &gt;信息列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=&quot; &apos;/event/create&apos; &quot; &gt;创建事件&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 这边的v-link 跟v-on一样，里面的默认是一个变量，如果想传递字符串进去，需要另加单引号 同理，@click，看这个例子 123// toggleActive()里面的如果直接是A，会认为是一个变量，无法得到，需要变成字符串 &lt;li :class=&quot;[&apos;tab-item&apos;,isA?&apos;tab-active&apos;:&apos;&apos;] &quot; @click=&quot;toggleAcitive(&apos;A&apos;)&quot;&gt;&lt;a v-link=&quot; &apos;/event/list&apos; &quot; &gt;信息列表&lt;/a&gt;&lt;/li&gt; &lt;li :class=&quot;[&apos;tab-item&apos;,!isA?&apos;tab-active&apos;:&apos;&apos;] &quot; @click=&quot;toggleAcitive(&apos;B&apos;)&quot;&gt;&lt;a v-link=&quot; &apos;/event/create&apos; &quot;&gt;创建事件&lt;/a&gt;&lt;/li&gt; class 动态绑定 1&lt;li class=&quot;pageList[0]===1?&apos;disabled&apos;:&apos;&apos;&quot;&gt; 这样是无法识别的，里面不是三元符，而是就是 一个字符串，需要加bind绑定才会变成三元表达式 input checkbox绑定到一个数组的时候，需要指定他们的value，否则相当于一个，会同时选中或不选中，指定后才会各自控制。 ajax ui体验优化 12345678910111213141516171819handleEventEdited(data)&#123; //直接更新 var temp = Object.assign(&#123;&#125;,this.eventList); this.eventList = this.eventList.map(event=&gt;&#123; if(event.name==data.name) return Object.assign(&#123;&#125;,event,&#123;name:data.newName&#125;); else return event; &#125;); //发送请求 this.$http.post(server_path+&quot;/event&quot;,data).then((response)=&gt;&#123; console.log(&quot;事件修改成功&quot;); &#125;,(err)=&gt;&#123; //修改失败后回退 this.eventList = temp; console.log(&quot;事件修改失败&quot;); &#125;); &#125;, 生命周期 楼主最近的开发过程中遇到这么一个问题，单页应用，最外层组件为app.vue。内层靠路由嵌套了几个子组件。子组件页面一加载就需要去发请求获取数据，而请求的param里面依赖父组件获得的数据。 在no组件，no单页的情况下，这种可以用一个页面加载同步请求去搞定。但是现在不允许这样。还牵扯到该在哪个合适的生命周期里去发送请求的问题。 困惑点1：之前写react的时候，官方建议在componentDidMount里面进行fetch,但是我比较疑惑的是为什么不在componentWillMount或者render里面操作。因为1，数据取得后就一直存在着，mount以后肯定可以显示。2，难道是因为willMount和render是在dom渲染，可能阻塞ui线程的问题。但是ajax是另开一个线程啊，应该是不影响的啊。 科普一下vue的生命周期，楼主大概打印了一下mount之前的执行顺序。 结合官网的生命周期列表，我们可以看到，都会经历如下的过程： beforeCreated-&gt; 生成data,computed 这些数据,初始化事件-&gt;created,实例对象被创建-&gt; 在从created到beforeMount过程中编译模板（template）-&gt; 编译完成后将template插入el或者父html中，这就完成了mounted。 而对于父组件，因为嵌套了子组件，它的mount需要等到子组件都处理完，生成el并插入document后才算完成。也就解释了上面打印的内容。 现在的规划大概是这样的，在父组件created的时候去fetch数据。然后在子组件中用v-if=’isParentDataGot’ 来确定装载与否。因为上面我们说了，子组件先创建实例，去计算这些data,既然父组件数据还未获取。那么本组件v-if === false。不显示但是子组件的生命周期还在进行。只是当父组件获取到后update,把数据附上去，然后在mounted里面去发送自己的请求。 困惑点2：楼主想知道是否可以在beforeMount里面return false来控制是否装载。困惑点3：一般是在mounted发送请求，那么vue现在的生命周期中，在created,beforeMount这些里面发送会有什么影响。 知识回顾 mouseenter mouseover区别mouseenter只在刚进入某个元素时触发，不会冒泡而mouseover在进入，以及在该元素上移动时都会触发 git远程合并楼主是项目owner的话，接受远程pull request后merge到dev分支。本地 12345git fetch bit-origin dev:new-branchgit checkout new-branch 查看最新代码。如果可以的话git checkout devgit merge new-branch。使得dev为最终代码git remove new-branch","categories":[{"name":"开发日常","slug":"开发日常","permalink":"http://yoursite.com/categories/开发日常/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"学习杂项","slug":"学习杂项","permalink":"http://yoursite.com/tags/学习杂项/"}]},{"title":"vue学习前传(一)","slug":"vue-prev-1","date":"2016-09-27T05:32:42.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2016/09/27/vue-prev-1/","link":"","permalink":"http://yoursite.com/2016/09/27/vue-prev-1/","excerpt":"","text":"react的项目结完最近又来了一个可视化的需求，在热力图上定制。好奇宝宝一直想知道angular跟vue的数据绑定跟react有什么区别，就试着上手了下vue，结果有点坑的是，公司的版本是0.12的，有些语法跟1.0的还不一样，比如v-repeat啥的,class的动态绑定比较鸡肋etc…害的我调了半天摔… 下面就来个demo把。vue实例demo See the Pen vue实例demo by lu (@luchen) on CodePen. 为什么jsfiddle经常挂= =，作业部落的markdown居然不能支持codepen直接嵌入html…就勉强戳链接看下啦。 12345678910111213141516//html&lt;h3&gt;测试部分&lt;/h3&gt;&lt;div id=\"app\"&gt; vue 0.12版本的class绑定&lt;br&gt; &#123;&#123;customClass?customClass+' red':\"red\"&#125;&#125; &lt;div class=\"&#123;&#123;customClass?customClass +' red':'red'&#125;&#125;\"&gt;class test&lt;/div&gt;&lt;/div&gt;&lt;h3&gt;实例demo&lt;/h3&gt;&lt;ul v-show=\"isChaoxi\" class=\"target-wrapper clearfix\"&gt; &lt;li v-repeat=\"product in productLines\" class=\"&#123;&#123;'sm-box-item '+product.customClass&#125;&#125;\" v-on=\"click:changeProduct(product.name)\"&gt; &lt;span class=\"box-item-data\"&gt;&#123;&#123;product.data&#125;&#125;&lt;/span&gt; &lt;span class=\"box-item-name\"&gt;&#123;&#123;product.zh_name&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//css.red&#123; color:red;&#125;.box-border&#123; border:1px solid black;&#125;.target-wrapper&#123; list-style:none; display: flex; margin-left: -10px;&#125;.sm-box-item&#123; flex: 1; margin-left: 10px; padding: 10px 20px; height: 78px; box-sizing: border-box; font-size: 18px; color: #fff; cursor: pointer;&#125;.box-item-data,.box-item-name&#123; width: 100%; display: block;&#125;.box-item-data&#123; text-align: left; font-size: 20px;&#125;.box-item-name&#123; text-align: right; font-size: 16px;&#125;.chaoxi&#123; background-color: #fd6252;&#125;.kuaiche&#123; background-color:#54c3bc;&#125;.taxi&#123; background-color: #106ed5;&#125;.sfc&#123; background-color: #00cd99;&#125;.zhuanche&#123; background-color: #9587e9;&#125; 1234567891011121314151617181920212223242526//javascriptvar testVue = new Vue(&#123; el:\"#app\", data:&#123; show:false, customClass:\"box-border\", test:\"test\" &#125;&#125;);var demoVue = new Vue(&#123; el:\".target-wrapper\", data:&#123; isChaoxi:true, productLines: [ &#123;data:'10000',zh_name:\"潮汐\",customClass:'chaoxi'&#125;, &#123;data:'30000',zh_name:\"出租车\",customClass:'taxi'&#125;, &#123;data:'8000',zh_name:\"快车\", customClass:'kuaiche'&#125;, &#123;data:'200',zh_name:\"专车\",customClass:'zhuanche'&#125;, &#123;data:'100',zh_name:\"顺风车\",customClass:'sfc'&#125; ] &#125;&#125;); 关于set,需要注意的是 在new Vue的时候没有设置的属性，是不可以用vobj.key = value来更新的。只能用$set.但是官方建议是在data中进行声明，不要动态设置。 原因有两点： 代码易读性 动态添加会强制所有的 watcher 重新计算，因为它之前不存在，没有 watcher 追踪它。虽然性能上差别不是很大，但是不建议。1editVobj.$set(&quot;fenceName&quot;,this.name); 而且如果key对应的value是一个对象的话，$set设置实际上会进行替换，而不是extend/object.assign。","categories":[{"name":"开发日常","slug":"开发日常","permalink":"http://yoursite.com/categories/开发日常/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"数据绑定","slug":"数据绑定","permalink":"http://yoursite.com/tags/数据绑定/"}]},{"title":"vue学习前传(三)","slug":"vue-todo","date":"2016-09-27T05:05:20.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2016/09/27/vue-todo/","link":"","permalink":"http://yoursite.com/2016/09/27/vue-todo/","excerpt":"","text":"之前用jquery写过一次todo，最近在学vue,（好吧其实这篇文章放上来的时候已经过了好久了，算是用vue开发项目的前传吧~，后续会慢慢放上项目demo讲解），下面就是用vue重构的todo的demo啦。,可能这边显示有问题，直接戳codepen的链接就好啦。 See the Pen todo via vue by lu (@luchen) on CodePen. v-model的双向绑定实际上也是用get-set(observer) 来实现的。对于的语句进行编译，其实是代理到_data内部属性，vm.message === vm._data.message，转变成为类似于上面的computed属性中的key，每个都有自己的get set方法。 其中，需要实现observer。对message创建observe对象1new Observer(&#123;message: &apos;Hello World&apos; &#125;) ， 实例化dep对象，用于下面的收集依赖,。紧接着通过convert方法（Observer.protoype.convert()）将属性变成reactive的，在这个方法中实现get,set get用于收集依赖于message的其他key set用于监听message变化后通知这些依赖，依赖的收集我们说过，是用dep实现的，具体来说是创建了一个subs数组来保存订阅者。 以上为init的一些操作，然后就到了mount部分：compile+link.compile主要是对el,template里面的内容进行解析，如1&#123;&#123;&#125;&#125; 需要创建元素，这边是textnode，然后append到fragment中（高性能javascript也提到过，是一个避免多次重绘重排的好方法）。link主要进行的操作就是实例化指令（这边是text指令），将指令和新建的元素（textnode）link在一起，然后将元素替换到DOM tree中去。 第一次渲染，会通过watcher去获得表达式”message”的计算值，更新到之前新建的TextNode中去，完成在页面上渲染:获取watcher数据的时候，会同时把它们加入到变化的订阅者集合中（即dep.subs数组中），一旦数据进行了变动，就会通过dep.notify() -&gt; watcher.update() -&gt; directive.update() -&gt; textDirective.update()，完成DOM的更新。 references Vue.js源码（1）：Hello World的背后 楼主来更新啦，最近对vuex比较感兴趣，就试着用vuex重构了一下todo，但是比较困惑的是关于v-model的问题。官方给出的建议是将v-model变成一个计算属性，这对于一个普通的变量不失为一个好的方法，但是我这边遇到的问题是，当我列表渲染的时候，里面有v-model，（v-model=”listitem.input”）这种，我该怎么去给它设置set函数？vuex的版本代码请戳链接todo","categories":[{"name":"开发日常","slug":"开发日常","permalink":"http://yoursite.com/categories/开发日常/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"todo","slug":"todo","permalink":"http://yoursite.com/tags/todo/"}]},{"title":"图解http(二)","slug":"图解http之二","date":"2016-09-27T04:45:38.000Z","updated":"2016-09-27T05:12:48.000Z","comments":true,"path":"2016/09/27/图解http之二/","link":"","permalink":"http://yoursite.com/2016/09/27/图解http之二/","excerpt":"","text":"chapter5 与http有关的web服务器 为什么请求头中要指定uri因现实生活中，有可能一个服务器上部署着多个服务，（虚拟服务器存在）域名不同，那么光有IP是没有用的都会定位到这个服务器，因此需要有指定的uri来唯一识别 客户端 代理服务器 源服务器每次经过代理服务器，都需要写入 via 首部信息到头请求头或者响应头。 chapter6 http首部chapter6 是http首部字段的一些说明，包括通用首部、请求首部、响应首部、实体首部以及一些没有放到http1.1的rfc里面但很常用的首部字段，包括cookie的一些字段及属性，如set-cookie的secure，httpOnly属性,cookie字段。还有其他的如DNT（do not trace，拒绝个人信息被搜集），p3p（保护用户隐私）的等等。具体可以查看书上的介绍，这部分不再赘述。 chapter7 确保web安全的httpspart1: 起因本章是基于http的以下三个缺点展开的： 通信内容可能被窃听（明文不加密） 被篡改（报文完整性X） 通信双方身份无法确认。 为什么不加密？因为加密了其实也可能被窃听，只是可能不会被破解而已。 如何防止被窃听——加密 通信加密：http+ ssl/tls 此处SSL出没相当于整个通信信道是安全的。 ssl:secure socket layer 安全套接字tls:transport layer security 传输层安全协议 内容加密此处仅对报文主体，不包括报文首部（请求头（请求行+请求首部））。缺点：内容有被篡改的可能。 如何确认通信方的身份——证书 不确认通信方的身份，可能会带来若干隐患： 服务器/客户端的伪造、 通信方的权限无法确认、 海量请求接受导致的Dos攻击SSL使用了一种被称为证书的手段。证书是有可信第三方颁发，用于确认服务器和客户端是实际存在的，并且证书的伪造极其困难。客户端在开始通信前先确认服务器的证书，保证是自己要访问的服务器。 如何保证通信内容不被篡改——摘要现实生活中，请求或者响应在传输过程中是可能被攻击者拦截后进行篡改的，这种就是中间人攻击。通常避免的方法有MD5和SHA-1等hash值校验的方法、数字签名（文件的数字签名可以用PGP来生成）。但这些方法都需要客户端的用户去亲自检查验证是否自己下载的文件就是服务器上的文件。而且一旦MD5，PGP这些被篡改的话，用户其实也无法发现。 综上，HTTPS可以解决以上三种问题，SSL提供了认证+加密处理+摘要的功能。它可以总结为 HTTPS = HTTP+ 加密+ 认证 +完整性保护 part2 HTTPS1. 使用ssl时，就从通常的http与tcp通信变成http-&gt;ssl-&gt;tcp-&gt;ip.. 【注】ssl是独立于http的协议的，其他运行在应用层的SMTP,Telnet等协议都可以与ssl配合使用。 2. https采取了共享秘钥加密+公开秘钥加密的混合加密方式补充知识： 加密分两种，对称/非对称，ssl采取的是非对称即公开秘钥加密 对称密钥（共享密钥），即加密解密都用同一个秘钥，缺点在于秘钥必须发送给对方，而传送时有可能就被窃听甚至获取到。 公开秘钥使用非对称密钥，公钥加密，私钥解密，公钥可以被任意共享。具体来说是，A发送给B，就用B的公钥加密，B收到后用自己的私钥解密优点在于安全性得到了极大的保障： 同时获取公钥私钥很困难 即使获得了破解也困难（大素数分解） 实际中，由于公开秘钥加密很慢，因此https采取了两种方式混合使用的方式，用公开密钥加密的方法去交换接下来在共享秘钥加密方式中的密钥，然后在确保密钥安全的前提下用共享秘钥的方式通信。 问题又来了…当你用公开秘钥加密的方法传输时，你怎么知道这个被你传的就是真正的公开秘钥。但是光有不行，因为不能证明公钥本身就是真正的公钥，有可能这个公钥已经被攻击者替换。因此，就需要证书来验证。 3. 证书 目的：用于确认服务器背后企业是否真实存在 流程： 服务器运营人员向 数字证书认证机构申请，机构用自己的私钥对申请的公开秘钥做数字签名，然后把这个公开密钥A放入公钥证书。然后服务器把证书给客户端。客户端要验证这个公钥证书是否是正确的，就直接把证书（公钥A+机构私钥组成的数字签名）连同浏览器内置好的认证机构的公钥B，去验证数字签名，以确定公钥A的真实性。 一旦验证这个公开密钥A是真实的，就可以继续用原来的 方式（公开密钥加密方式去交换对称密钥，然后共享秘钥方式加解密）….好绕口=。= 其实就相当于在原来的基础上多了一步验证公开密钥的真实性。而这个秘钥的真实性的验证是借助可信证书机构的公私密钥来解决的。 4. 完整版本的https 通信机制正确的流程是：服务器：服务器每次传送，都需要发：//服务器sendData = 信息+ signature +数字证书。//signature = md5(信息)+ 服务器私钥加密//数字证书 = 服务器公钥 + 机构私钥 加密后结果 客户端客户端拿到以后，用浏览器的机构公钥解密，得到服务器公钥，然后去解谜收到的东西，得到的就是 md5以后的 信息 A。然后将信件本身md5后生成B 。AB进行判断是否相等。就可以看信件是否篡改了。 在这个过程中，先用机构公钥解密验证 身份，再用服务器公钥揭秘再比对实现 篡改验证。 5. ssl速度慢主要包括两种，一种是通信慢，ssl连接时要通信，另一种是，在服务器客户端都要进行加解密的处理，需要消耗CPU及内存资源。因此不一直使用HTTPS。 chapter8 确认用户身份的认证同第七章的证书（服务器认证）不一样的是，这一章是针对客户端的认证，主要包括以下几种，以后几章都用思维导图来总结啦。 chapter9 基于http的追加功能、协议 chapter11 web攻击","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"图解http(一)","slug":"图解http","date":"2016-09-27T04:37:46.000Z","updated":"2016-09-27T04:44:54.000Z","comments":true,"path":"2016/09/27/图解http/","link":"","permalink":"http://yoursite.com/2016/09/27/图解http/","excerpt":"","text":"chapter1 web及网络基础思维导图 chapter2 简单的http协议 http协议用于客户端和服务器之间通信。 请求报文： 12GET /index.htm HTTP/1.1Host: hackr.jp 请求方法 请求URI 协议版本 以上三个位请求行 请求头+内容实体 响应报文 http 不保存状态（stateless）但实际中，需要保持状态，比如用户登录信息，这个时候利用cookie等。 http方法 get post put：传输文件，状态码如204，表示该文件已经存在于服务器上。由于HTTP1.1中的put方法自身不带验证机制，任何人都可以上传文件，存在安全问题。一般网站不使用该方法，除非有自定义的验证机制/rest标准设计。put是幂等的。 HEAD(同get,但不返回报文主体内容，用于确认URI有效性及资源更新的内容), DELETE：删除文件，同put一样，不安全，响应：204（no content） TRACE: 讲之前的请求通信环回给客户端。 Connect：用隧道协议连接代理，主要用SSL。TLS协议把通信内容加密后经网络隧道传输。 持久连接 最开始的时候，每请求（指http）一次就要断开tcp再新建一次连接（包括，tcp三次握手建立连接，请求，响应，四次握手断开tcp连接）。开销太大。(比如一个html中还有图片资源，这个也是请求。)为解决上述问题，提出了持久连接。（只要一方不提出断连，就一直保持tcp连接，可以多个http请求。）http1.1默认持久连接，但1.0不是引申：使得pipeline成为可能，多个请求可以并行发送。 cookie第一次客户端请求后，服务端生成cookie，要求客户端set cookie，然后下次客户端请求时便会自动加入cookie信息，服务端再根据这个进行判别。服务端仍然是无状态的。 chapter3 http报文内的http信息 请求报文 三部分： 报文首部（请求头）+ 请求行：方法、URI、协议版本 + 首部字段： 通用首部、请求首部|响应首部、实体首部 + 其他：如cookie 空行、 报文主体 内容协商以返回最合适的内容 比如访问macy.com，梅西百货，它会根据浏览器的默认语言，返回相应的web页面，如中文版。 以相应资源的字符集、编码方式、语言作为判断的基准。 chapter4 http状态码 2XX成功 200 ok 204 no content:在服务器不需要向客户端返回信息时用 206 partial content, 范围请求 3XX重定向 301 moved parmanantly .永久性重定向，如保存的书签需要更新。 302 found 临时性重定向，仅一次 303 see other，请求资源有另一个URI，需要用get方法重定向获取。部分区别于302 304 not modified 4XX 客户端错误 400 bad request 请求报文中有语法错误 401 unauthorized 要登录/登录失败’ 403 forbidden 权限问题 404 not found 5XX 服务器错误 500 internal server error。 503 service unavailable，服务器在超负载正忙retry-after字段","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"从requirejs看模块化","slug":"从requirejs看模块化","date":"2016-08-21T09:10:35.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2016/08/21/从requirejs看模块化/","link":"","permalink":"http://yoursite.com/2016/08/21/从requirejs看模块化/","excerpt":"","text":"requirejs优势（使用场景） 防止js加载阻塞页面渲染（async属性） 避免命名冲突以及为避免冲突所作的若干挣扎…，甚至还有一种情况是：不同版本的依赖库，如jquery，可以通过赋以不同的命名加以区分。 更好的依赖处理，解决：文件依赖导致需要小心翼翼的放置各js，以确保它们的加载顺序。 教程 各模块专注于单一的功能，仅暴露出必要的部分 改善性能问题。按需加载，减少不必要的加载。也可以将很少更新的合并成一个文件，用缓存，经常变动的独立成模块，互不影响。 实战演练define跟require的区别在于一个是用于定义模块的，一个是使用已定义的模块的。以下demo是可以运行的，但是放到codepen中，require存在问题，待解决，此处仅供代码参考。 See the Pen requirejsDemo by lu (@luchen) on CodePen. fis中的mod.js里面的require实习的过程中最痛心的就是遗留代码的加功能点…之前的fe是用的旧版本的fis中的mod.js，定义了citylist组件，导致页面上要用到这一部分就得使用mod中的require。然后比较神奇的有这么几点 require函数的大体思想就是，定义一个全局对象，然后把引入的js文件作为一个一个的key,value存进去，每次进require函数，就去找这个对象，如果没有，就添加，如果有，就更新，保证全局唯一，某种程度上避免了不同模块是不同的fe写的，然后重复引用js的问题。但是比较坑爹的是，需要手动加script标签引入…如此反人类…当然也提供了require.async来异步引入，这个函数中它是可以createScript的，也就是说，你只要提供url,它会在head中 append script元素。 还有一点注意的是，require做了部分兼容，就是如果传给他的是一个数组对象，那么它会调用require.async。 关于类比require中的path,mod里面也有resourceMap进行处理， 123456789101112131415161718192021222324require.resourceMap(&#123; res:&#123; 'cityList':&#123; url:'/static/js/app/module_cityList.js' &#125;, 'echarts':&#123; url:'/static/hotmap/js/libs/echarts/echarts.common.js' &#125;, 'moment':&#123; url:\"/static/hotmap/js/libs/moment/moment.js\" &#125;, 'BMap':&#123; url:'http://api.map.baidu.com/api?v=2.0&amp;ak=8WEtlKYLwwssirUarD5O7ba0.js' &#125;, 'heatForm':&#123; url:\"/static/hotmap/js/components/formRelated.js\" &#125;, &#125;, 'HeatmapOverlay':&#123; deps:['BMap'], //**类似于shim** url:'http://api.map.baidu.com/library/Heatmap/2.0/src/Heatmap_min.js' &#125; &#125; &#125;); eg.1var moment = require(['moment']); 并不是我们通常意义上理解的模块、同步、引入。= = demo如图。 其中，heatform的文件映射见上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103define('heatForm',function(require,exports, module)&#123; var moment = require(['moment']); var $ = require([\"jquery\"]); var o = &#123;&#125;; var target = $(\"#target\"); //指标 var productLine = $(\"#productLine\"); var particleSize = $(\"#particleSize\"); var hourRange = $(\"#hourRange\"); var searchBtn = $(\"#searchBtn\"); //对应于size的当前时间的format，如粒度为15时，现在7:35，output:7:30-7:45 function getCurStart(size) &#123; if (size == 0) size = 1; var intervals = moment().diff(moment(&#123; h: 0, m: 0 &#125;), 'm'); var result = moment(&#123; h: 0, m: 0 &#125;).add(Math.floor(intervals / size) * size, 'm').format(\"HH:mm\"); return result; &#125; //时间段的下拉菜单html function generateRangeHtml(size) &#123; var totalMinutesOneDay = 1440, durationsArr = [], intervals; if (size === 0) &#123; size = 1; intervals = moment().diff(moment(&#123; h: 0, m: 0 &#125;), 'm') + 1; &#125; else intervals = totalMinutesOneDay / size; for (var i = 0; i &lt; intervals; i++) &#123; var durations = i * size; var h = Math.floor(durations / 60); var m = durations - h * 60; var startTime = moment(&#123; hour: h, minute: m &#125;); var endTime = moment(&#123; hour: h, minute: m &#125;).add(size, 'm'); durationsArr.push(&#123; startTime: startTime.format('HH:mm'), endTime: endTime.format(\"HH:mm\") &#125;); &#125; var curTime = getCurStart(size); var newOptions = durationsArr.map(function(one) &#123; if (one.startTime === curTime) &#123; return `&lt;option selected=$&#123;\"selected\"&#125; value=$&#123;one.startTime&#125;&gt;$&#123;one.startTime&#125;-$&#123;one.endTime&#125;&lt;/option&gt;` &#125; else return `&lt;option value=$&#123;one.startTime&#125;&gt;$&#123;one.startTime&#125;-$&#123;one.endTime&#125;&lt;/option&gt;`; &#125;).join(\"\"); return newOptions; &#125; function bindEvent() &#123; particleSize.on(\"change\", function(event) &#123; var size = parseInt($(this).val()); var newRangeOptions = generateRangeHtml(size); hourRange.html(newRangeOptions); &#125;); productLine.on(\"change\", function(event) &#123; var product = $(this).val(); if (product === \"sfc\") &#123; target.html(\"&lt;option value='callNum'&gt;呼叫量&lt;/option&gt;\"); &#125;else&#123; target.html( [\"&lt;option value='needNum'&gt;需求数&lt;/option&gt;\", \"&lt;option value='callNum'&gt;呼叫量&lt;/option&gt;\"].join(\"\")); &#125; &#125;); target.on(\"change\",function(event)&#123; var $this = $(this); var sfcOption = \"&lt;option value='sfc'&gt;顺风车&lt;/option&gt;\" if(($this).val()===\"needNum\")&#123; productLine.children(\".sfc\").remove(); &#125;else&#123; if(productLine.children(\".sfc\")===-1) productLine.append(sfcOption); &#125; &#125;); //待加入searchBtn的click事件 &#125; o.bindEvent = bindEvent; // return o; module.exports=o;&#125;); 1234//调用require.async('heatForm', function(heatForm) &#123; heatForm.bindEvent(); &#125;) AMD,CMD,UMD概览一般 require 用于处理页面首屏所需要的模块，require.async 用于处理首屏外的按需模块。1234567891011&#123;script type=&quot;text/javascript&quot;&#125; // 同步调用 jquery var $ = require(&apos;common:widget/jquery/jquery.js&apos;); $(&apos;#btn&apos;).click(function() &#123; // 异步调用 respClick 模块 require.async([&apos;/widget/ui/respClick/respClick.js&apos;], function() &#123; respClick.hello(); &#125;); &#125;); &#123;/script&#125; 三者代码示例AMD:见上 CMD:123456789101112131415//commonjs// 文件名: foo.jsvar $ = require('jquery');var _ = require('underscore');// methodsfunction a()&#123;&#125;; // 私有方法，因为它没在module.exports中 (见下面)function b()&#123;&#125;; // 公共方法，因为它在module.exports中定义了function c()&#123;&#125;; // 公共方法，因为它在module.exports中定义了// 暴露公共方法module.exports = &#123; b: b, c: c&#125;; 此处需要注意exports是module.exports的一个引用，如果直接使用123exports = &#123; ...&#125; 暴露模块的输出的话，是无效的。因为此时相当于exports的引用对象更改了，两者并不指向同一个对象。module.exports指向的才是。 UMD:123456789101112131415161718192021222324//UMD(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD define(['jquery', 'underscore'], factory); &#125; else if (typeof exports === 'object') &#123; // Node, CommonJS之类的 module.exports = factory(require('jquery'), require('underscore')); &#125; else &#123; // 浏览器全局变量(root 即 window) root.returnExports = factory(root.jQuery, root._); &#125;&#125;(this, function ($, _) &#123; // 方法 function a()&#123;&#125;; // 私有方法，因为它没被返回 (见下面) function b()&#123;&#125;; // 公共方法，因为被返回了 function c()&#123;&#125;; // 公共方法，因为被返回了 // 暴露公共方法 return &#123; b: b, c: c &#125;&#125;)); 函数有两个参数，第一个参数是当前运行时环境，第二个参数是模块的定义体。在执行UMD规范时，会优先判断是当前环境是否支持AMD环境，然后再检验是否支持CommonJS环境，否则认为当前环境为浏览器环境（ window ）。 从模块加载流程看amd,cmd区别总结来说，cmd是异步加载、延迟且同步执行、依赖就近amd是异步加载（下载）、异步执行、依赖前置。 （1）示例1234567891011121314151617181920//AMDdefine([\"./a\", \"./b\"], function(a, b) &#123; //BEGIN 1 if (true) &#123; a.doSomething(); &#125; else &#123;b.doSomething(); &#125; //END&#125;);//CMDdefine(function(require) &#123; // BEGIN 2 if(some_condition) &#123; require('./a').doSomething(); &#125; else &#123; require('./b').soSomething(); &#125; // END&#125;); 在BEGIN1位置处a、b模块都需要被执行一次。CMD中BEGIN 2处a、b都没有被执行，在END处，a、b只有一个被实际执行过。这就是cmd所说的延迟加载。 （2）大致流程以requirejs为例，其实amd,cmd的流程基本一样，区别在于后面的执行方面。 requirejs：用registry（{id:module}）来维持一个全局的模块资源表，保证不重复，每次根据id来查找，有则返回，无则去new Module。new Module的时候会触发Module.init函数，依次进行createScript，loading，将模块的依赖加入到依赖数组里，触发自己的completeLoad事件，在该事件中，依次去get依赖的Module,(在getModule时又会回到上面的步骤，有则返回，无则new Module).再接下来会做 checkLoaded,其中每隔50ms去checkoutLoadTimeoutId，因为模块是异步加载的，所以用这个来保证加载结束。 define函数中进行了兼容，包括无id,无依赖的，commonjs写法的（这种情况下同seajs一样，factory.toString()后正则匹配出依赖项）等多种情况。 seajs:异步下载脚本模块,下载后，浏览器会自动执行 define(fn),define 方法会保存 fn 和提取该模块的依赖模块（利用 fn.toString）,按照上面的方法，把依赖模块都下载好接着根据依赖关系，依次执行各个模块的 fn。 （3）区别/相同点 同：amd,cmd都是通过设置createElement(script),且设置async属性=true,因此它们都是async,异步下载的。 异1（执行时刻）：amd是并行加载后就执行，而cmd是as lazy as possible,先并行加载，但是直到require使用时才会执行。因此相对会耗费了时间。举个栗子，amd中，define(id,[],factory),[]指示的依赖数组就相当于cmd里面的那个require,那个require就是执行~ 异2（执行顺序）：amd是异步执行（执行顺序不定），而cmd是同步执行（当然也可以设置require.async去异步执行） 注：amd,cmd都是基于commonjs的，commonjs服务于服务端，cmd和amd作用于浏览器端，因为cmd中的require是同步执行，需要执行完才能执行下面的代码，对于浏览器端来说，是一个很大的性能问题，因为模块在服务器端，完全拼网速。 “ 因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。” –阮一峰 （4）补充requirejs性能好点的原因： 解析依赖时直接就可以知道，不需要像seajs一样 function.to String()后正则匹配require后的依赖 异步加载执行，而cmd同步执行耗时参考amd,cmd cmd 中require的加载与执行的关系？require的时候实际上是已经加载好了，去执行 exec()12345678seajs.require = function(id) &#123; var mod = Module.get(Module.resolve(id)) if (mod.status &lt; STATUS.EXECUTING) &#123; mod.onload() mod.exec() &#125; return mod.exports&#125; 补充知识： 浏览器通常解析script的时候是同步下载、同步阻塞执行。除非手动设置了async，defer等属性具体总结来说 defer:异步下载、最后（document被解析之后）执行，仍然在DOMContentLoaded之前 async：异步下载后立刻异步执行（执行时可能页面还在解析，不block parse，顺序不定）且在window的load事件之前执行 不设置：同步下载、同步执行，在页面继续解析之前，因此会阻塞 2，动态创建script标签并插入==设置为async references Asynchronous and deferred JavaScript execution explained script的defer和async 以代码爱好者角度来看AMD与CMD seajs 源码解读 to think: es6中的module机制以及webpack的处理","categories":[{"name":"intern","slug":"intern","permalink":"http://yoursite.com/categories/intern/"}],"tags":[{"name":"requirejs","slug":"requirejs","permalink":"http://yoursite.com/tags/requirejs/"},{"name":"模块化","slug":"模块化","permalink":"http://yoursite.com/tags/模块化/"},{"name":"AMD","slug":"AMD","permalink":"http://yoursite.com/tags/AMD/"},{"name":"CMD","slug":"CMD","permalink":"http://yoursite.com/tags/CMD/"}]},{"title":"github+hexo搭建博客","slug":"测试","date":"2016-08-16T08:23:37.000Z","updated":"2017-02-28T05:01:34.000Z","comments":true,"path":"2016/08/16/测试/","link":"","permalink":"http://yoursite.com/2016/08/16/测试/","excerpt":"","text":"安装1.安装hexo生成blog步骤： 1234npm install hexo-cli -ghexo init blogcd bloghexo server //localhost:4000打开即可 会看到，blog文件夹下的目录为： 其中一些hexo的插件是在node_modules里面被默认安装了。package.json里面也可以看到相关版本及插件 【补充】常用命令 新建 123hexo new fileName//输出的信息如下INFO Created: e:\\GraduateSemester2\\summer\\blog\\source\\_posts\\测试.md 可以看到，我们进入source文件夹里面的_posts文件夹，里面编辑markdown文件即可 预览 12hexo s //打开localhost:4000直接预览 2,配置github 新建一个与github username同名的repository 假设我的名字是pokemon,则repository新建为pokemon.github.io， git clone 新建的repository 转到刚刚hexo的文件夹，运行 12hexo g //生成public静态资源文件，会看到blog文件夹下多了一个public文件夹 3,部署 更改hexo的config.yml 1234deploy: type: git repo: https://github.com/liz282907/liz282907.github.io.git branch: master **注意点**： （1）type：【空格】...，然后才会生效 （2）deploy插件要安装 1npm install hexo-deployer-git --save （3）每次更改文件后，都得重新 hexo generate以生效，然后才能最终部署。否则会遇到莫名其妙的443,github打不开的问题 1hexo g 部署生效 1hexo deploy 会让你输入github的用户名，密码 完成后，会显示下图 ![deploy成功图](http://i2.buimg.com/567571/a70832f19113fb9d.png) 更换主题下载主题hexo中有多种主题可供选择，萝卜青菜各有所爱啦，楼主喜欢简洁风，就选择的是next主题 12cd bloggit clone https://github.com/iissnan/hexo-theme-next themes/next 配置config12更改config.yml的theme:theme:next 清理缓存并验证12hexo cleanhexo s --debug //预览并打开调试模式 个性化设置添加多说评论框申请多说域名 点击多说官网的我要安装,填写相关的信息，注意多说域名中要填写的部分即为站点配置文件中要增加的short_name。12# comment duoshuoduoshuo_shortname: luchen-blog 更改themes中的模板 修改themes你的主题文件夹(这边为next)的模板文件：themes\\next\\layout_partials\\comments.swig 添加如下代码（因为新版本的next已经做了兼容了，即duoshuo+facebook+disqus，只需要增加多说的评论框即可） 1234567891011&lt;script type=&quot;text/javascript&quot;&gt;var duoshuoQuery = &#123;short_name:&quot;luchen-blog&quot;&#125;; (function() &#123; var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt; 补充：获取user_id:访问多说后台 ，点击用户名，网页上会显示href,其中profile后面的一串就是你的user_id 此时再打开如username.github.io就可以啦 4，查看效果 添加站点统计信息注册百度统计给自己的站点，如yoursite.github.io 增加统计信息。 插入统计代码 放置于之前,具体来说，找到blog/themes\\next\\layout_partials\\head.swig,在最后一行加入上面的统计代码即可。 更改站点配置文件增加baidu_analytics: your site id 即可在百度统计网站里看到访问情况了 更新（Windows-&gt;Mac迁移后的一系列问题fix）划重点就是，删除不必要的文件，按照以前的方式部署，有问题去GitHub看下当前repo的setting里面有没有报warning或者有没有收到build error的邮件。 需要注意一下几点： 如果主题是通过git管理的，需要将主题文件夹下的.git文件夹删除或者使用git submodule的形式进行管理，才能同步Blog文件夹，submodule的话是添加.gitsubmodules文件，将依赖的submodule添加进去，楼主这边是theme/next,但是声明了以后没有用，就直接删除了themes/next下面的.git 文件夹 Blog目录下自带的.gitignore文件，node_modules文件夹是不会同步的，所以同步之后需要自己再次进行npm install，但是注意，不要进行hexo init了，否则_config.yml会被覆盖。 hexo generate出现yaml解析错误等等检查下config.yaml是否写错，主题或者文章里面是否有中英文标点符号的问题，space not tab等等。 hexo deploy 无限等待一直卡在这边，需要输入以下命令看看出错点sudo hexo deploy --debug 免密部署之前每次部署前都要输入密码，现在可以生成rsa-key,添加到GitHub上。具体的步骤见官网，最后验证下图以及执行： 12//openssh 6.8以上ssh-add -l -E md5 查看md5与GitHub上的md5是否匹配。 注意：mac中要添加下面的命令： 1ssh-add -K ~/.ssh/id_rsa ssh-add 默认将制定的秘钥添加在当前运行的 ssh-agent 服务中，但是你可以改变这个默认行为让它添加到 keychain 服务中，让 Mac 来帮你记住、管理并保障这些秘钥的安全性。 在修改主题文件之后，页面的文件依然没有更新。解决方案： hexo clean并且删除.deploy_git文件夹之后，hexo d -g。为了强制浏览器更新资源文件，可以强制刷新。删除.deploy_git时如果有 directory not empty的问题，应该是文件夹还被占用，推出占用的程序即可。 permission denied解决方案: sudo hexo deploy -g references: build-github-blog-page hexo api next主题 多说教程 Hexo常见问题解决方案 todo hexo插件 阅读次数 分享链接 高亮、jsfiddle引入、read more","categories":[],"tags":[{"name":"gitPages","slug":"gitPages","permalink":"http://yoursite.com/tags/gitPages/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}